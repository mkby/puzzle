<!DOCTYPE html>
<html lang="zh-CN" class="h-full">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å½±åƒå¤§å¸ˆ</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“¸</text></svg>">

    <!-- Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Oswald:wght@500&family=Roboto+Mono:wght@400&family=Dancing+Script:wght@400;700&family=Great+Vibes&family=Sacramento&family=Parisienne&family=Allura&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#7c3aed', // Violet-600 (matching landing page)
                        secondary: '#10B981',
                        brand: {
                            light: '#a78bfa', // Violet-400
                            DEFAULT: '#7c3aed', // Violet-600
                            dark: '#6d28d9', // Violet-700
                        },
                        background: '#020617', // Deep Midnight (Slate-950)
                        foreground: '#f8fafc', // Slate-50
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        display: ['Oswald', 'sans-serif'],
                        mono: ['Roboto Mono', 'monospace'],
                        'dancing': ['"Dancing Script"', 'cursive'],
                        'great-vibes': ['"Great Vibes"', 'cursive'],
                        'sacramento': ['"Sacramento"', 'cursive'],
                        'parisienne': ['"Parisienne"', 'cursive'],
                        'allura': ['"Allura"', 'cursive'],
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .dark ::-webkit-scrollbar-thumb {
            background: #475569;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        .dark ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Range Input */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3B82F6;
            cursor: pointer;
            margin-top: -4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: transparent;
            border-radius: 4px;
        }

        /* Grid Cell */
        .grid-cell {
            position: relative;
            overflow: hidden;
            background-color: #f3f4f6;
            cursor: grab;
        }

        .dark .grid-cell {
            background-color: #1f2937;
        }

        .grid-cell:active {
            cursor: grabbing;
        }

        .grid-cell img {
            position: absolute;
            will-change: transform;
            user-select: none;
            pointer-events: none;
            max-width: none !important;
            max-height: none !important;
        }

        /* Ratio Button */
        .ratio-btn.active {
            background-color: #eff6ff;
            border-color: #3b82f6;
            color: #2563eb;
        }

        .dark .ratio-btn.active {
            background-color: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
        }

        /* Tab Button */
        .tab-btn {
            position: relative;
        }

        .tab-btn.active {
            color: #2563EB;
            background-color: #EFF6FF;
            border-color: #BFDBFE;
        }

        .tab-btn.active::after {
            display: none;
        }

        /* Hide scrollbar for Chrome, Safari and Opera */
        .custom-scrollbar::-webkit-scrollbar {
            display: none;
        }

        /* Hide scrollbar for IE, Edge and Firefox */
        .custom-scrollbar {
            -ms-overflow-style: none;
            /* IE and Edge */
            scrollbar-width: none;
            /* Firefox */
        }

        .dark .tab-btn.active {
            color: #60A5FA;
            background-color: rgba(37, 99, 235, 0.2);
            border-color: #1E40AF;
        }

        .dark .tab-btn.active::after {
            display: none;
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-fade-in {
            animation: fadeIn 0.4s ease-out forwards;
        }

        /* Canvas Interaction Classes */
        .cursor-grab {
            cursor: grab;
        }

        .cursor-grabbing {
            cursor: grabbing;
        }
    </style>
</head>

<body
    class="h-full bg-gray-50 dark:bg-slate-950 text-gray-900 dark:text-gray-100 transition-colors duration-200 flex flex-col md:flex-row overflow-auto md:overflow-hidden font-sans">

    <!-- Sidebar -->
    <aside id="mainSidebar"
        class="w-full md:w-[360px] bg-white dark:bg-slate-900 border-b md:border-b-0 md:border-r border-gray-200 dark:border-slate-800 flex flex-col shadow-lg z-10 shrink-0 relative group"
        style="min-width: 280px; max-width: 600px;">
        <!-- Resize Handle -->
        <div id="sidebarResizer"
            class="hidden md:block absolute right-0 top-0 bottom-0 w-1 cursor-col-resize hover:bg-violet-600 transition-colors z-50 opacity-0 group-hover:opacity-100">
        </div>
        <!-- Header -->
        <div class="bg-white dark:bg-slate-900 border-b border-gray-200 dark:border-slate-800">
            <!-- Top Bar -->
            <div class="px-6 py-5 flex justify-between items-center">
                <div class="flex items-center gap-3">
                    <div
                        class="w-10 h-10 bg-gradient-to-tr from-violet-600 to-indigo-700 rounded-xl flex items-center justify-center shadow-lg shadow-violet-600/20 text-white">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z">
                            </path>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"></path>
                        </svg>
                    </div>
                    <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-violet-400 to-cyan-400 tracking-tight"
                        data-i18n="brand">
                        å½±åƒå¤§å¸ˆ</h1>
                </div>
                <div class="flex items-center gap-1">
                    <button id="globalApiSettingsBtn"
                        class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-800 transition-colors text-gray-500 dark:text-slate-400 hover:text-violet-600 dark:hover:text-violet-400"
                        title="AI API è®¾ç½®">
                        <i class="fa-solid fa-gear text-lg"></i>
                    </button>
                    <button id="langToggle"
                        class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-800 transition-colors text-gray-500 dark:text-slate-400 hover:text-violet-600 dark:hover:text-violet-400 font-bold"
                        title="Switch Language">
                        <span id="langToggleText">EN</span>
                    </button>
                    <button id="themeToggle"
                        class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-800 transition-colors text-gray-500 dark:text-slate-400 hover:text-yellow-500 dark:hover:text-yellow-400">
                        <svg id="sunIcon" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z">
                            </path>
                        </svg>
                        <svg id="moonIcon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z">
                            </path>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Tab Switcher -->
            <div class="grid grid-cols-3 gap-2 px-4 pb-4">
                <button
                    class="tab-btn active w-full py-2 text-xs font-medium text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-gray-300 transition-all rounded-lg border border-transparent hover:bg-gray-50 dark:hover:bg-slate-800/50"
                    data-tab="puzzle" data-i18n="tab.puzzle">
                    æ‹¼å›¾å¤§å¸ˆ
                </button>
                <button
                    class="tab-btn w-full py-2 text-xs font-medium text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-gray-300 transition-all rounded-lg border border-transparent hover:bg-gray-50 dark:hover:bg-slate-800/50"
                    data-tab="frame" data-i18n="tab.frame">
                    è¾¹æ¡†å¤§å¸ˆ
                </button>
                <button
                    class="tab-btn w-full py-2 text-xs font-medium text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-gray-300 transition-all rounded-lg border border-transparent hover:bg-gray-50 dark:hover:bg-slate-800/50"
                    data-tab="watermark" data-i18n="tab.watermark">
                    æ°´å°å¤§å¸ˆ
                </button>
                <button
                    class="tab-btn w-full py-2 text-xs font-medium text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-gray-300 transition-all rounded-lg border border-transparent hover:bg-gray-50 dark:hover:bg-slate-800/50"
                    data-tab="tag" data-i18n="tab.tag">
                    æ ‡ç­¾å¤§å¸ˆ
                </button>
                <button
                    class="tab-btn w-full py-2 text-xs font-medium text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-gray-300 transition-all rounded-lg border border-transparent hover:bg-gray-50 dark:hover:bg-slate-800/50"
                    data-tab="content" data-i18n="tab.content">
                    æ–‡æ¡ˆå¤§å¸ˆ
                </button>
                <button
                    class="tab-btn w-full py-2 text-xs font-medium text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-gray-300 transition-all rounded-lg border border-transparent hover:bg-gray-50 dark:hover:bg-slate-800/50"
                    data-tab="wallpaper" data-i18n="tab.wallpaper">
                    å£çº¸å¤§å¸ˆ
                </button>
            </div>
        </div>

        <!-- Puzzle Sidebar Content -->
        <div id="puzzle-sidebar" class="flex-1 overflow-y-auto p-6 space-y-8">
            <!-- Upload -->
            <section>
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="upload.title">
                    å›¾ç‰‡ä¸Šä¼ 
                </h2>
                <div id="puzzleDropZone"
                    class="border-2 border-dashed border-gray-300 dark:border-slate-700 rounded-xl p-6 text-center hover:border-violet-500 dark:hover:border-blue-400 transition-colors cursor-pointer bg-gray-50 dark:bg-slate-800/50">
                    <input type="file" id="puzzleFileInput" multiple accept="image/*" class="hidden">
                    <svg class="w-10 h-10 mx-auto text-gray-400 mb-3" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                        </path>
                    </svg>
                    <p class="text-sm text-gray-600 dark:text-slate-300" data-i18n="upload.drag">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å›¾ç‰‡</p>
                    <p class="text-xs text-gray-400 mt-1" data-i18n="upload.sub">æ”¯æŒ 300 å¼ å›¾ç‰‡</p>
                </div>
                <div id="puzzleFileList" class="mt-4 grid grid-cols-4 gap-2"></div>
            </section>

            <section id="puzzleLayoutSection" class="hidden">
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="puzzle.layout">
                    é€‰æ‹©ç‰ˆå¼
                </h2>
                <div id="layoutSelector" class="grid grid-cols-4 gap-2">
                    <!-- Dynamic Content -->
                </div>
                <div class="border-b border-gray-200 dark:border-slate-800 my-4"></div>
            </section>

            <section id="yearMaskSection" class="hidden">
                 <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3" data-i18n="puzzle.year_mask">
                    2025 åº•å›¾è®¾ç½®
                </h2>
                <div id="yearMaskDropZone" onclick="document.getElementById('yearMaskInput').click()"
                    class="border-2 border-dashed border-violet-300 dark:border-violet-800 rounded-xl p-4 text-center hover:border-violet-500 transition-colors cursor-pointer bg-violet-50 dark:bg-slate-800/50">
                    <input type="file" id="yearMaskInput" accept="image/*" class="hidden">
                    <div class="flex flex-col items-center gap-2">
                        <svg class="w-6 h-6 text-violet-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                        <p class="text-xs text-violet-600 dark:text-violet-400">ä¸Šä¼ åº•å›¾ (å°†æ˜¾ç¤ºåœ¨æ•°å­—ä¸­)</p>
                    </div>
                </div>
                <div class="mt-3">
                    <label class="block text-xs text-gray-500 dark:text-gray-400 mb-2">æ¸å˜åº•è‰²:</label>
                    <div class="flex items-center gap-2">
                         <div class="flex-1 flex items-center gap-2 bg-gray-50 dark:bg-slate-800 rounded p-1 border border-gray-200 dark:border-slate-700">
                             <input type="color" id="yearGradientStart" value="#8b5cf6" class="w-6 h-6 rounded cursor-pointer border-none p-0 bg-transparent">
                             <span class="text-xs text-gray-400">èµ·å§‹</span>
                         </div>
                         <span class="text-gray-300 dark:text-slate-600">â†’</span>
                         <div class="flex-1 flex items-center gap-2 bg-gray-50 dark:bg-slate-800 rounded p-1 border border-gray-200 dark:border-slate-700">
                             <input type="color" id="yearGradientEnd" value="#d946ef" class="w-6 h-6 rounded cursor-pointer border-none p-0 bg-transparent">
                             <span class="text-xs text-gray-400">ç»“æŸ</span>
                         </div>
                    </div>
                </div>
                <div class="mt-3 flex items-center justify-between gap-2">
                    <div class="flex items-center gap-2">
                        <label class="text-xs text-gray-500 dark:text-gray-400">å¯†åº¦:</label>
                        <select id="yearScaleSelect" class="text-xs bg-transparent border border-gray-200 dark:border-slate-700 rounded px-1 py-1 outline-none text-gray-600 dark:text-gray-300">
                            <option value="1">1x (é»˜è®¤)</option>
                            <option value="2">2x (é«˜)</option>
                            <option value="3">3x (è¶…é«˜)</option>
                        </select>
                    </div>
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" id="yearMergeCheck" class="w-3 h-3 rounded accent-violet-600">
                        <span class="text-xs text-gray-500 dark:text-gray-400">è‡ªåŠ¨åˆå¹¶</span>
                    </label>
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" id="yearVerticalCheck" class="w-3 h-3 rounded accent-violet-600">
                        <span class="text-xs text-gray-500 dark:text-gray-400">ç«–å‘æ’åˆ—</span>
                    </label>
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" id="yearRepeatCheck" checked class="w-3 h-3 rounded accent-violet-600">
                        <span class="text-xs text-gray-500 dark:text-gray-400">å¾ªç¯å¡«å……</span>
                    </label>
                </div>
                <!-- Year Text Input -->
                <div class="mt-3">
                    <label class="block text-xs text-gray-500 dark:text-gray-400 mb-1">å¹´ä»½æ•°å­— (4ä½):</label>
                    <input type="text" id="yearTextInput" value="2025" maxlength="4" class="w-full bg-white dark:bg-slate-900 border border-gray-200 dark:border-slate-700 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-violet-500 outline-none text-center font-mono tracking-widest">
                </div>
                <div class="border-b border-gray-200 dark:border-slate-800 my-4"></div>
            </section>

            <section>
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="puzzle.ratio">
                    ç”»å¸ƒæ¯”ä¾‹
                </h2>
                <div class="grid grid-cols-3 gap-2 mb-3">
                    <button
                        class="ratio-btn active px-3 py-2 text-sm rounded-lg border border-gray-200 dark:border-slate-700 hover:bg-gray-100 dark:hover:bg-slate-800 transition-colors bg-violet-50 dark:bg-blue-900/30 border-violet-500 text-violet-600 dark:text-blue-400"
                        data-ratio="1:1">1:1</button>
                    <button
                        class="ratio-btn px-3 py-2 text-sm rounded-lg border border-gray-200 dark:border-slate-700 hover:bg-gray-100 dark:hover:bg-slate-800 transition-colors"
                        data-ratio="4:3">4:3</button>
                    <button
                        class="ratio-btn px-3 py-2 text-sm rounded-lg border border-gray-200 dark:border-slate-700 hover:bg-gray-100 dark:hover:bg-slate-800 transition-colors"
                        data-ratio="16:9">16:9</button>
                    <button
                        class="ratio-btn px-3 py-2 text-sm rounded-lg border border-gray-200 dark:border-slate-700 hover:bg-gray-100 dark:hover:bg-slate-800 transition-colors"
                        data-ratio="3:4">3:4</button>
                    <button
                        class="ratio-btn px-3 py-2 text-sm rounded-lg border border-gray-200 dark:border-slate-700 hover:bg-gray-100 dark:hover:bg-slate-800 transition-colors"
                        data-ratio="9:16">9:16</button>
                    <button
                        class="ratio-btn px-3 py-2 text-sm rounded-lg border border-gray-200 dark:border-slate-700 hover:bg-gray-100 dark:hover:bg-slate-800 transition-colors"
                        id="customRatioBtn" data-i18n="puzzle.custom">è‡ªå®šä¹‰</button>
                </div>
                <div id="customRatioInput" class="hidden flex items-center space-x-2">
                    <input type="number" id="ratioW" placeholder="W"
                        class="w-full px-3 py-2 rounded-lg border border-gray-300 dark:border-slate-700 bg-transparent text-sm focus:ring-2 focus:ring-blue-600 outline-none">
                    <span class="text-gray-400">:</span>
                    <input type="number" id="ratioH" placeholder="H"
                        class="w-full px-3 py-2 rounded-lg border border-gray-300 dark:border-slate-700 bg-transparent text-sm focus:ring-2 focus:ring-blue-600 outline-none">
                </div>
            </section>

            <section>
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="puzzle.border">
                    è¾¹æ¡†è®¾ç½®
                </h2>
                <div class="space-y-4">
                    <div>
                        <label class="flex justify-between text-sm text-gray-600 dark:text-slate-300 mb-1">
                            <span data-i18n="puzzle.border.width">ç²—ç»†</span>
                            <span id="borderWidthVal">1px</span>
                        </label>
                        <input type="range" id="borderWidth" min="0" max="20" value="1"
                            class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
                    </div>
                    <div>
                        <label class="flex justify-between text-sm text-gray-600 dark:text-slate-300 mb-1">
                            <span data-i18n="puzzle.border.color">é¢œè‰²</span>
                        </label>
                        <!-- Custom Input Group -->
                        <div class="flex items-center gap-2">
                            <div class="relative w-10 h-10">
                                <input type="color" id="borderColor" value="#000000"
                                    class="absolute inset-0 opacity-0 w-full h-full cursor-pointer z-10">
                                <div id="borderColorPreview"
                                    class="w-full h-full rounded-lg border border-gray-200 shadow-sm transition-colors"
                                    style="background-color: #000000;"></div>
                            </div>
                            <input type="text" id="borderColorText" value="#000000"
                                class="flex-1 px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-gray-50 dark:bg-slate-800 text-sm font-mono focus:ring-2 focus:ring-blue-600 outline-none uppercase transition-all">
                        </div>
                    </div>
                </div>
            </section>

            <div class="pt-4">
                <div class="space-y-4 mb-6">
                    <div class="flex justify-between items-center">
                        <label class="text-sm font-medium text-gray-700 dark:text-slate-300"
                            data-i18n="quality.label">å¯¼å‡ºè´¨é‡</label>
                        <span id="puzzleQualityVal" class="text-xs text-gray-500 font-mono">85%</span>
                    </div>
                    <input type="range" id="puzzleQuality" min="10" max="100" value="85"
                        class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
                </div>

                <button id="puzzleDownloadBtn" disabled
                    class="w-full py-4 bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white rounded-xl font-medium shadow-lg shadow-violet-600/30 transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                    </svg>
                    <span data-i18n="btn.download">ä¸‹è½½å›¾ç‰‡</span>
                </button>
            </div>
        </div>

        <!-- Frame Sidebar Content -->
        <div id="frame-sidebar" class="hidden flex-1 overflow-y-auto p-6 space-y-8">
            <!-- Upload -->
            <section>
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="upload.title">
                    å›¾ç‰‡ä¸Šä¼ 
                </h2>
                <div id="frameDropZone"
                    class="border-2 border-dashed border-gray-300 dark:border-slate-700 rounded-xl p-6 text-center hover:border-violet-500 dark:hover:border-blue-400 transition-colors cursor-pointer bg-gray-50 dark:bg-slate-800/50 relative">
                    <input type="file" id="frameFileInput" multiple accept="image/*" class="hidden">
                    <svg class="w-10 h-10 mx-auto text-gray-400 mb-3" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                        </path>
                    </svg>
                    <p class="text-sm text-gray-600 dark:text-slate-300" data-i18n="upload.drag">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å›¾ç‰‡</p>
                    <p class="text-xs text-gray-400 mt-1" data-i18n="upload.batch">æ”¯æŒæ‰¹é‡å¤„ç†</p>
                    <div id="frameFileCount"
                        class="absolute top-2 right-2 bg-violet-500 text-white text-xs font-bold px-2 py-0.5 rounded hidden">
                        0</div>
                </div>
                <div id="frameFileList" class="mt-4 grid grid-cols-4 gap-2"></div>
            </section>

            <!-- Border Type Selection -->
            <section>
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="frame.type">
                    è¾¹æ¡†ç±»å‹
                </h2>
                <div class="grid grid-cols-2 gap-2">
                    <button id="frameBorderTypeBlur"
                        class="border-type-btn active py-2 px-3 text-sm rounded-lg border-2 border-violet-500 bg-violet-50 dark:bg-blue-900/20 text-violet-600 dark:text-blue-400 font-medium transition-all"
                        data-i18n="frame.type.blur">
                        æ¨¡ç³ŠèƒŒæ™¯
                    </button>
                    <button id="frameBorderTypeSolid"
                        class="border-type-btn py-2 px-3 text-sm rounded-lg border-2 border-gray-200 dark:border-slate-700 text-gray-600 dark:text-slate-400 hover:border-gray-300 dark:hover:border-gray-500 transition-all"
                        data-i18n="frame.type.solid">
                        çº¯è‰²è¾¹æ¡†
                    </button>
                    <button id="frameBorderTypeGradient"
                        class="border-type-btn py-2 px-3 text-sm rounded-lg border-2 border-gray-200 dark:border-slate-700 text-gray-600 dark:text-slate-400 hover:border-gray-300 dark:hover:border-gray-500 transition-all"
                        data-i18n="frame.type.gradient">
                        æ¸å˜èƒŒæ™¯
                    </button>
                    <button id="frameBorderTypeMatte"
                        class="border-type-btn py-2 px-3 text-sm rounded-lg border-2 border-gray-200 dark:border-slate-700 text-gray-600 dark:text-slate-400 hover:border-gray-300 dark:hover:border-gray-500 transition-all"
                        data-i18n="frame.type.matte">
                        åŒå±‚å¡çº¸
                    </button>
                </div>
            </section>

            <section id="frameSolidColorSection" class="hidden">
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="frame.color">
                    è¾¹æ¡†é¢œè‰²
                </h2>
                <div class="flex items-center gap-2">
                    <div class="relative w-10 h-10">
                        <input type="color" id="frameBorderColor" value="#000000"
                            class="absolute inset-0 opacity-0 w-full h-full cursor-pointer z-10">
                        <div id="frameBorderColorPreview"
                            class="w-full h-full rounded-lg border border-gray-200 shadow-sm transition-colors"
                            style="background-color: #000000;"></div>
                    </div>
                    <input type="text" id="frameBorderColorText" value="#000000"
                        class="flex-1 px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-gray-50 dark:bg-slate-800 text-sm font-mono focus:ring-2 focus:ring-blue-600 outline-none uppercase transition-all">
                </div>
            </section>

            <section id="frameParametersSection">
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="frame.params">
                    å‚æ•°è°ƒæ•´
                </h2>
                <div class="space-y-6">
                    <div>
                        <label class="flex justify-between text-sm text-gray-600 dark:text-slate-300 mb-1">
                            <span data-i18n="frame.param.width">è¾¹æ¡†å®½åº¦</span>
                            <span id="frameBorderVal">120</span>
                        </label>
                        <input type="range" id="frameBorderRange" min="50" max="400" value="120"
                            class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
                    </div>
                    <div id="frameBlurSection">
                        <label class="flex justify-between text-sm text-gray-600 dark:text-slate-300 mb-1">
                            <span data-i18n="frame.param.blur">èƒŒæ™¯æ¨¡ç³Š</span>
                            <span id="frameBlurVal">20</span>
                        </label>
                        <input type="range" id="frameBlurRange" min="0" max="100" value="20"
                            class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
                    </div>
                    <div>
                        <label class="flex justify-between text-sm text-gray-600 dark:text-slate-300 mb-1">
                            <span data-i18n="frame.param.font">æ–‡å­—å¤§å°</span>
                            <span id="frameFontVal">1.0x</span>
                        </label>
                        <input type="range" id="frameFontRange" min="0.5" max="2.0" step="0.1" value="1.0"
                            class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
                    </div>
                </div>
            </section>

            <!-- EXIF Toggle -->
            <section>
                <div class="flex items-center justify-between">
                    <span class="text-sm text-gray-600 dark:text-slate-300 font-medium" data-i18n="frame.exif">æ˜¾ç¤ºæ‹æ‘„å‚æ•°
                        (EXIF)</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="frameExifToggle" checked class="sr-only peer">
                        <div
                            class="w-11 h-6 bg-gray-200 dark:bg-slate-800 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-violet-600">
                        </div>
                    </label>
                </div>
            </section>

            <!-- Quality -->
            <div class="space-y-4 mt-6">
                <div class="flex justify-between items-center">
                    <label class="text-sm font-medium text-gray-700 dark:text-slate-300"
                        data-i18n="quality.label">å¯¼å‡ºè´¨é‡</label>
                    <span id="frameQualityVal" class="text-xs text-gray-500 font-mono">85%</span>
                </div>
                <input type="range" id="frameQuality" min="10" max="100" value="85"
                    class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
            </div>

            <!-- Actions -->
            <div class="pt-4 space-y-3">
                <button id="frameGenerateBtn" disabled
                    class="w-full bg-gradient-to-r from-violet-600 to-indigo-600 hover:from-violet-700 hover:to-indigo-700 text-white font-semibold py-3 px-4 rounded-xl shadow-lg shadow-violet-600/30 transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center space-x-2 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z">
                        </path>
                    </svg>
                    <span data-i18n="btn.generate">å¼€å§‹ç”Ÿæˆ</span>
                </button>
                <button id="frameDownloadAllBtn" disabled
                    class="w-full bg-gray-100 dark:bg-slate-800 text-gray-500 dark:text-slate-400 font-medium py-3 px-4 rounded-xl flex items-center justify-center space-x-2 transition-all disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-200 dark:hover:bg-slate-700">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                    </svg>
                    <span data-i18n="btn.download_all">æ‰“åŒ…ä¸‹è½½å…¨éƒ¨</span>
                </button>
            </div>
        </div>

        <!-- Watermark Sidebar Content -->
        <div id="watermark-sidebar" class="hidden flex-1 overflow-y-auto p-6 space-y-8">
            <!-- Image Upload -->
            <section>
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="upload.title">
                    å›¾ç‰‡ä¸Šä¼ 
                </h2>
                <div id="wmDropZone"
                    class="border-2 border-dashed border-gray-300 dark:border-slate-700 rounded-xl p-6 text-center hover:border-violet-500 dark:hover:border-blue-400 transition-colors cursor-pointer bg-gray-50 dark:bg-slate-800/50">
                    <input type="file" id="wmImageInput" accept="image/*" class="hidden">
                    <svg class="w-10 h-10 mx-auto text-gray-400 mb-3" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                        </path>
                    </svg>
                    <p class="text-sm text-gray-600 dark:text-slate-300" data-i18n="upload.drag">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å›¾ç‰‡</p>
                    <p class="text-xs text-gray-400 dark:text-gray-500 mt-1" data-i18n="wm.upload.sub">æ”¯æŒå¤šç§æ°´å°åŠŸèƒ½</p>
                </div>
            </section>

            <!-- Watermark Controls -->
            <div id="wmControls" class="space-y-8 animate-fade-in">

                <!-- Toggle Type -->
                <div class="flex bg-gray-100 dark:bg-slate-800 rounded-lg p-1 gap-1">
                    <button id="wmTypeImage"
                        class="flex-1 py-1.5 text-xs sm:text-sm font-medium rounded-md bg-white dark:bg-gray-600 shadow-sm text-violet-600 dark:text-blue-400 transition-all"
                        data-i18n="wm.type.image">å›¾ç‰‡</button>
                    <button id="wmTypeText"
                        class="flex-1 py-1.5 text-xs sm:text-sm font-medium rounded-md text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-gray-200 transition-all"
                        data-i18n="wm.type.text">æ–‡å­—</button>
                    <button id="wmTypePalette"
                        class="flex-1 py-1.5 text-xs sm:text-sm font-medium rounded-md text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-gray-200 transition-all"
                        data-i18n="wm.type.palette">è‰²å¡</button>
                    <button id="wmTypeHistogram"
                        class="flex-1 py-1.5 text-xs sm:text-sm font-medium rounded-md text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-gray-200 transition-all"
                        data-i18n="wm.type.histogram">ç›´æ–¹å›¾</button>
                </div>
            </div>

            <!-- Image Watermark Section -->
            <div id="wmSectionImage" class="space-y-4">
                <div class="flex gap-3">
                    <button id="wmUploadBtn"
                        class="flex-1 py-2.5 border border-gray-200 dark:border-slate-700 rounded-lg text-sm font-medium hover:bg-gray-50 dark:hover:bg-slate-800 transition-all flex items-center justify-center gap-2 text-gray-600 dark:text-slate-300">
                        <i class="fa-solid fa-upload"></i> <span data-i18n="wm.btn.upload">ä¸Šä¼ æ°´å°å›¾</span>
                    </button>
                    <input type="file" id="wmWatermarkInput" accept="image/png" class="hidden">
                </div>
            </div>

            <!-- Text Signature Section -->
            <div id="wmSectionText" class="hidden space-y-4">
                <div class="space-y-2">
                    <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                        data-i18n="wm.text.content">ç­¾åå†…å®¹</label>
                    <input type="text" id="wmSigText" placeholder="è¾“å…¥ç­¾å..." data-i18n="wm.text.placeholder"
                        class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-transparent text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200"
                        value="My Signature">
                </div>
                <div class="space-y-2">
                    <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                        data-i18n="wm.text.font">å­—ä½“é£æ ¼</label>
                    <select id="wmFontSelect"
                        class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                        <option value="Dancing Script">Dancing Script</option>
                        <option value="Great Vibes">Great Vibes</option>
                        <option value="Sacramento">Sacramento</option>
                        <option value="Parisienne">Parisienne</option>
                        <option value="Allura">Allura</option>
                        <option value="Inter">Inter (Simple)</option>
                    </select>
                </div>
                <div class="space-y-2">
                    <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                        data-i18n="wm.text.color">é¢œè‰²</label>
                    <div class="flex gap-2 items-center">
                        <input type="color" id="wmSigColor" value="#000000"
                            class="w-8 h-8 rounded cursor-pointer border-0 p-0">
                        <button class="w-6 h-6 rounded-full bg-black border border-gray-200"
                            onclick="document.getElementById('wmSigColor').value='#000000'; WatermarkApp.updateSignature()"></button>
                        <button class="w-6 h-6 rounded-full bg-white border border-gray-200"
                            onclick="document.getElementById('wmSigColor').value='#ffffff'; WatermarkApp.updateSignature()"></button>
                        <button class="w-6 h-6 rounded-full bg-gray-500 border border-gray-200"
                            onclick="document.getElementById('wmSigColor').value='#6b7280'; WatermarkApp.updateSignature()"></button>
                    </div>
                </div>
                <button id="wmAddSigBtn"
                    class="w-full py-2 bg-gradient-to-r from-violet-600 to-indigo-600 hover:from-violet-700 hover:to-indigo-700 text-white rounded-lg text-sm font-medium transition-colors"
                    data-i18n="wm.btn.add">
                    ç”Ÿæˆå¹¶æ·»åŠ 
                </button>
                <div class="flex gap-2">
                    <button id="wmSaveSigBtn"
                        class="flex-1 py-1.5 text-xs border border-gray-200 dark:border-slate-700 rounded text-gray-500 dark:text-slate-400 hover:text-blue-500 transition-colors"
                        data-i18n="wm.btn.save">
                        ä¿å­˜é¢„è®¾
                    </button>
                    <button id="wmDownloadSigBtn"
                        class="flex-1 py-1.5 text-xs border border-gray-200 dark:border-slate-700 rounded text-gray-500 dark:text-slate-400 hover:text-blue-500 transition-colors"
                        data-i18n="wm.btn.export">
                        å¯¼å‡ºPNG
                    </button>
                </div>
            </div>

            <!-- Palette Section -->
            <div id="wmSectionPalette" class="hidden space-y-4">
                <div class="space-y-2">
                    <div class="flex justify-between">
                        <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                            data-i18n="wm.palette.count">é¢œè‰²æ•°é‡</label>
                        <span id="wmPaletteCountVal" class="text-xs text-gray-500">5</span>
                    </div>
                    <input type="range" id="wmPaletteCountRange" min="3" max="8" value="5"
                        class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
                </div>
                <div class="space-y-2">
                    <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                        data-i18n="wm.palette.style">æ ·å¼</label>
                    <select id="wmPaletteStyle"
                        class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                        <option value="circle" data-i18n="wm.palette.circle">åœ†å½¢</option>
                        <option value="square" data-i18n="wm.palette.square">æ–¹å½¢</option>
                        <option value="strip" data-i18n="wm.palette.strip">é•¿æ¡</option>
                    </select>
                </div>
                <button id="wmGeneratePaletteBtn"
                    class="w-full py-2 bg-gradient-to-r from-violet-600 to-indigo-600 hover:from-violet-700 hover:to-indigo-700 text-white rounded-lg text-sm font-medium transition-colors"
                    data-i18n="wm.btn.generate_palette">
                    ç”Ÿæˆè‰²å¡
                </button>
            </div>

            <!-- Histogram Section -->
            <div id="wmSectionHistogram" class="hidden space-y-4">
                <div class="space-y-2">
                    <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                        data-i18n="wm.palette.style">æ ·å¼</label>
                    <select id="wmHistogramStyle"
                        class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                        <option value="rgb" data-i18n="wm.histogram.rgb">RGB é‡å </option>
                        <option value="luminance" data-i18n="wm.histogram.luminance">äº®åº¦ (ç™½è‰²)</option>
                        <option value="color" data-i18n="wm.histogram.color">å½©è‰²åˆ†å¸ƒ</option>
                    </select>
                </div>
                <button id="wmGenerateHistogramBtn"
                    class="w-full py-2 bg-gradient-to-r from-violet-600 to-indigo-600 hover:from-violet-700 hover:to-indigo-700 text-white rounded-lg text-sm font-medium transition-colors"
                    data-i18n="wm.btn.generate_histogram">
                    ç”Ÿæˆç›´æ–¹å›¾
                </button>
            </div>

            <!-- Common Adjustments -->
            <div class="pt-4 border-t border-gray-200 dark:border-slate-800 space-y-4">
                <div class="space-y-2">
                    <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                        data-i18n="wm.pos">ä½ç½®é¢„è®¾</label>
                    <div class="grid grid-cols-3 gap-2">
                        <button
                            class="wm-pos-btn p-2 rounded border border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-800 text-gray-400"
                            data-pos="top-left"><i class="fa-solid fa-arrow-up"
                                style="transform: rotate(-45deg);"></i></button>
                        <button
                            class="wm-pos-btn p-2 rounded border border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-800 text-gray-400"
                            data-pos="top-center"><i class="fa-solid fa-arrow-up"></i></button>
                        <button
                            class="wm-pos-btn p-2 rounded border border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-800 text-gray-400"
                            data-pos="top-right"><i class="fa-solid fa-arrow-up"
                                style="transform: rotate(45deg);"></i></button>
                        <button
                            class="wm-pos-btn p-2 rounded border border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-800 text-gray-400"
                            data-pos="center-left"><i class="fa-solid fa-arrow-left"></i></button>
                        <button
                            class="wm-pos-btn p-2 rounded border border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-800 text-gray-400"
                            data-pos="center"><i class="fa-solid fa-arrows-to-dot"></i></button>
                        <button
                            class="wm-pos-btn p-2 rounded border border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-800 text-gray-400"
                            data-pos="center-right"><i class="fa-solid fa-arrow-right"></i></button>
                        <button
                            class="wm-pos-btn p-2 rounded border border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-800 text-gray-400"
                            data-pos="bottom-left"><i class="fa-solid fa-arrow-down"
                                style="transform: rotate(45deg);"></i></button>
                        <button
                            class="wm-pos-btn p-2 rounded border border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-800 text-gray-400"
                            data-pos="bottom-center"><i class="fa-solid fa-arrow-down"></i></button>
                        <button
                            class="wm-pos-btn p-2 rounded border border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-800 text-gray-400"
                            data-pos="bottom-right"><i class="fa-solid fa-arrow-down"
                                style="transform: rotate(-45deg);"></i></button>
                    </div>
                </div>

                <div class="space-y-2">
                    <div class="flex justify-between">
                        <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                            data-i18n="wm.size">å¤§å°</label>
                        <span id="wmScaleVal" class="text-xs text-gray-500">100%</span>
                    </div>
                    <input type="range" id="wmScaleRange" min="10" max="200" value="100"
                        class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
                </div>

                <div class="space-y-2">
                    <div class="flex justify-between">
                        <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                            data-i18n="wm.opacity">ä¸é€æ˜åº¦</label>
                        <span id="wmOpacityVal" class="text-xs text-gray-500">100%</span>
                    </div>
                    <input type="range" id="wmOpacityRange" min="0" max="100" value="100"
                        class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
                </div>
            </div>

            <!-- Export -->
            <div class="pt-4 border-t border-gray-200 dark:border-slate-800 space-y-4">
                <div class="space-y-2">
                    <div class="flex justify-between">
                        <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                            data-i18n="quality.label">å¯¼å‡ºè´¨é‡</label>
                        <span id="wmQualityVal" class="text-xs text-gray-500">90%</span>
                    </div>
                    <input type="range" id="wmQualityRange" min="10" max="100" value="90"
                        class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
                </div>
                <button id="wmExportBtn" disabled
                    class="w-full py-4 bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white rounded-xl font-medium shadow-lg shadow-violet-600/30 transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                    </svg>
                    <span data-i18n="btn.download">ä¸‹è½½å›¾ç‰‡</span>
                </button>
            </div>
        </div>
        </div>

        <!-- Tag Master Sidebar Content -->
        <div id="tag-sidebar" class="hidden flex-1 overflow-y-auto p-6 space-y-8">
            <!-- Upload -->
            <section>
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="upload.title">
                    å›¾ç‰‡ä¸Šä¼ 
                </h2>
                <div id="tagDropZone"
                    class="border-2 border-dashed border-gray-300 dark:border-slate-700 rounded-xl p-6 text-center hover:border-violet-500 dark:hover:border-blue-400 transition-colors cursor-pointer bg-gray-50 dark:bg-slate-800/50">
                    <svg class="w-10 h-10 mx-auto mb-3 text-gray-400" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                        </path>
                    </svg>
                    <p class="text-sm text-gray-600 dark:text-slate-300" data-i18n="upload.drag">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å›¾ç‰‡</p>
                    <p class="text-xs text-gray-400 dark:text-gray-500 mt-1" data-i18n="upload.batch">æ”¯æŒæ‰¹é‡å¤„ç†</p>
                </div>
                <input type="file" id="tagFileInput" accept="image/*" multiple class="hidden">
            </section>

            <!-- Settings -->
            <section>
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="tag.settings">
                    æ ‡ç­¾è®¾ç½®
                </h2>

                <div class="space-y-4">
                    <!-- Tag Count -->
                    <div class="space-y-2">
                        <div class="flex justify-between">
                            <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                                data-i18n="tag.count">æ ‡ç­¾æ•°é‡</label>
                            <span id="tagCountVal" class="text-xs text-gray-500">15</span>
                        </div>
                        <input type="range" id="tagCountRange" min="5" max="30" value="15"
                            class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
                    </div>

                    <!-- Language -->
                    <div class="space-y-2">
                        <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                            data-i18n="tag.lang">æ ‡ç­¾è¯­è¨€</label>
                        <select id="tagLanguage"
                            class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                            <option value="auto" data-i18n="tag.lang.auto">è‡ªåŠ¨æ£€æµ‹</option>
                            <option value="zh" data-i18n="tag.lang.zh">ä¸­æ–‡</option>
                            <option value="en" data-i18n="tag.lang.en">English</option>
                        </select>
                    </div>
                </div>
            </section>

            <!-- Generate Button -->
            <section>
                <button id="tagGenerateBtn"
                    class="w-full py-4 bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white rounded-xl font-medium shadow-lg shadow-violet-600/30 transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
                    disabled>
                    <i class="fa-solid fa-wand-magic-sparkles"></i>
                    <span data-i18n="tag.btn.generate">ç”Ÿæˆæ ‡ç­¾</span>
                </button>
            </section>

            <!-- Batch Actions -->
            <section id="tagResultSection" class="hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-semibold text-gray-800 dark:text-gray-100" data-i18n="tag.batch">æ‰¹é‡æ“ä½œ</h2>
                    <div class="flex gap-2">
                        <button id="tagClearAllBtn"
                            class="px-3 py-1.5 text-xs border border-red-200 dark:border-red-900/50 rounded text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors">
                            <i class="fa-solid fa-trash"></i> <span data-i18n="tag.btn.clear">æ¸…ç©ºå†å²</span>
                        </button>
                        <button id="tagCopyAllBtn"
                            class="px-3 py-1.5 text-xs border border-gray-200 dark:border-slate-700 rounded text-gray-500 dark:text-slate-400 hover:text-blue-500 hover:border-violet-500 transition-colors">
                            <i class="fa-solid fa-copy"></i> <span data-i18n="tag.btn.copy">å¤åˆ¶å…¨éƒ¨ç»“æœ</span>
                        </button>
                    </div>
                </div>
                <div class="text-sm text-gray-500 dark:text-slate-400" data-i18n="tag.hint">
                    å·²ç”Ÿæˆæ ‡ç­¾çš„å›¾ç‰‡ç»“æœå°†æ˜¾ç¤ºåœ¨å³ä¾§ç½‘æ ¼ä¸­ã€‚
                </div>
            </section>
        </div>

        <!-- Content Master Sidebar -->
        <div id="content-sidebar" class="hidden flex-1 overflow-y-auto p-6 space-y-8">
            <!-- Upload Section -->
            <section>
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="upload.title">
                    å›¾ç‰‡ä¸Šä¼ 
                </h2>
                <div id="contentDropZone"
                    class="border-2 border-dashed border-gray-300 dark:border-slate-700 rounded-xl p-6 text-center hover:border-violet-500 dark:hover:border-blue-400 transition-colors cursor-pointer bg-gray-50 dark:bg-slate-800/50 relative">
                    <input type="file" id="contentFileInput" accept="image/*" class="hidden">
                    <svg class="w-10 h-10 mx-auto text-gray-400 mb-3" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                        </path>
                    </svg>
                    <p class="text-sm text-gray-600 dark:text-slate-300" data-i18n="upload.drag">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å›¾ç‰‡</p>
                    <p class="text-xs text-gray-400 dark:text-gray-500 mt-1" data-i18n="upload.single">æ”¯æŒå•å¼ å›¾ç‰‡</p>
                </div>
            </section>

            <!-- Context Input -->
            <section>
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3">
                    <span data-i18n="content.info">è¡¥å……ä¿¡æ¯</span>
                    <span class="text-xs font-normal text-gray-400" data-i18n="content.optional">(å¯é€‰)</span>
                </h2>
                <textarea id="contentUserInput" rows="3" placeholder="è¾“å…¥å…³é”®è¯ã€äº§å“ä¿¡æ¯æˆ–æƒ³è¦è¡¨è¾¾çš„å†…å®¹..."
                    data-i18n="content.placeholder"
                    class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none resize-none dark:text-gray-200"></textarea>
            </section>

            <!-- Style Selection -->
            <section>
                <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                    data-i18n="content.style">
                    æ–‡æ¡ˆé£æ ¼
                </h2>
                <select id="contentStyle"
                    class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                    <option value="general" data-i18n="content.style.general">é€šç”¨</option>
                    <option value="zhongcao" data-i18n="content.style.zhongcao">ç§è‰</option>
                    <option value="photography" data-i18n="content.style.photography">æ‘„å½±</option>
                    <option value="tutorial" data-i18n="content.style.tutorial">æ•™ç¨‹</option>
                    <option value="daily" data-i18n="content.style.daily">æ—¥å¸¸</option>
                </select>
            </section>

            <!-- Actions -->
            <section class="space-y-3">
                <button id="contentGenerateBtn" disabled
                    class="w-full bg-gradient-to-r from-violet-600 to-indigo-600 hover:from-violet-700 hover:to-indigo-700 text-white font-semibold py-3 px-4 rounded-xl shadow-lg shadow-violet-600/30 transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center space-x-2 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none">
                    <i class="fa-solid fa-wand-magic-sparkles"></i>
                    <span data-i18n="content.btn.generate">ç”Ÿæˆæ–‡æ¡ˆ</span>
                </button>
            </section>
        </div>

        <!-- Wallpaper Master Sidebar -->
        <div id="wallpaper-sidebar" class="hidden flex-1 overflow-y-auto p-6 space-y-8">
            <!-- Mode Toggle -->
            <section>
                <div class="flex bg-gray-100 dark:bg-slate-800 rounded-lg p-1 gap-1">
                    <button id="wallpaperModeAI"
                        class="flex-1 py-2 text-sm font-medium rounded-md bg-white dark:bg-gray-600 shadow-sm text-violet-600 dark:text-blue-400 transition-all"
                        data-i18n="wp.mode.ai">
                        AIç”Ÿæˆ
                    </button>
                    <button id="wallpaperModeCustom"
                        class="flex-1 py-2 text-sm font-medium rounded-md text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-gray-200 transition-all"
                        data-i18n="wp.mode.custom">
                        è‡ªå®šä¹‰å›¾ç‰‡
                    </button>
                </div>
            </section>

            <!-- AI Generation Mode -->
            <div id="wallpaperAISection" class="space-y-6">
                <!-- Style Selection -->
                <section>
                    <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                        data-i18n="wp.style">
                        å£çº¸é£æ ¼
                    </h2>
                    <select id="wallpaperStyle"
                        class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                        <option value="nature" data-i18n="wp.style.nature">è‡ªç„¶é£å…‰</option>
                        <option value="cityscape" data-i18n="wp.style.cityscape">åŸå¸‚é£å…‰</option>
                        <option value="abstract" data-i18n="wp.style.abstract">æŠ½è±¡è‰ºæœ¯</option>
                        <option value="minimalist" data-i18n="wp.style.minimalist">æç®€ä¸»ä¹‰</option>
                        <option value="anime" data-i18n="wp.style.anime">åŠ¨æ¼«äºŒæ¬¡å…ƒ</option>
                        <option value="space" data-i18n="wp.style.space">å®‡å®™æ˜Ÿç©º</option>
                        <option value="gradient" data-i18n="wp.style.gradient">æ¸å˜è‰²å½©</option>
                        <option value="pattern" data-i18n="wp.style.pattern">å‡ ä½•å›¾æ¡ˆ</option>
                    </select>
                </section>

                <!-- Aspect Ratio Selection -->
                <section>
                    <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                        data-i18n="wp.ratio">
                        å°ºå¯¸æ¯”ä¾‹
                    </h2>
                    <select id="wallpaperAspectRatio"
                        class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                        <option value="16:9" data-i18n="wp.ratio.16_9">16:9 æ¨ªå± (1664Ã—928)</option>
                        <option value="4:3" data-i18n="wp.ratio.4_3">4:3 æ¨ªå± (1472Ã—1140)</option>
                        <option value="1:1" data-i18n="wp.ratio.1_1">1:1 æ­£æ–¹å½¢ (1328Ã—1328)</option>
                        <option value="3:4" data-i18n="wp.ratio.3_4">3:4 ç«–å± (1140Ã—1472)</option>
                        <option value="9:16" selected data-i18n="wp.ratio.9_16">9:16 ç«–å± (928Ã—1664)</option>
                    </select>
                </section>

                <!-- Generate Button -->
                <section>
                    <button id="wallpaperGenerateBtn"
                        class="w-full bg-gradient-to-r from-violet-600 to-indigo-600 hover:from-violet-700 hover:to-indigo-700 text-white font-semibold py-3 px-4 rounded-xl shadow-lg shadow-violet-600/30 transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center space-x-2 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none">
                        <i id="wallpaperGenerateBtnIcon" class="fa-solid fa-wand-magic-sparkles"></i>
                        <span id="wallpaperGenerateBtnText" data-i18n="wp.btn.generate">ç”Ÿæˆå£çº¸</span>
                    </button>
                </section>

            </div>

            <!-- Custom Image Mode -->
            <div id="wallpaperCustomSection" class="hidden space-y-6">
                <!-- Upload Section -->
                <section>
                    <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                        data-i18n="upload.title">
                        å›¾ç‰‡ä¸Šä¼ 
                    </h2>
                    <div id="wallpaperDropZone"
                        class="border-2 border-dashed border-gray-300 dark:border-slate-700 rounded-xl p-6 text-center hover:border-violet-500 dark:hover:border-blue-400 transition-colors cursor-pointer bg-gray-50 dark:bg-slate-800/50">
                        <input type="file" id="wallpaperFileInput" accept="image/*" class="hidden">
                        <svg class="w-10 h-10 mx-auto text-gray-400 mb-3" fill="none" stroke="currentColor"
                            viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                            </path>
                        </svg>
                        <p class="text-sm text-gray-600 dark:text-slate-300" data-i18n="upload.drag">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å›¾ç‰‡</p>
                        <p class="text-xs text-gray-400 dark:text-gray-500 mt-1" data-i18n="wp.drag.hint">æ”¯æŒæ‹–æ‹½ç¼©æ”¾è°ƒæ•´</p>
                    </div>
                </section>

                <!-- Device Size Presets -->
                <section id="wallpaperDeviceSection" class="hidden">
                    <h2 class="text-sm font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wider mb-3"
                        data-i18n="wp.device">
                        è®¾å¤‡å°ºå¯¸
                    </h2>
                    <select id="wallpaperDeviceSize"
                        class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                        <optgroup label="iPhone" data-i18n="wp.device.group.iphone">
                            <option value="iphone15promax">iPhone 15 Pro Max (1290x2796)</option>
                            <option value="iphone15pro">iPhone 15 Pro (1179x2556)</option>
                            <option value="iphone15">iPhone 15 (1179x2556)</option>
                            <option value="iphone14pro">iPhone 14 Pro (1179x2556)</option>
                            <option value="iphone14">iPhone 14 (1170x2532)</option>
                            <option value="iphone13">iPhone 13 (1170x2532)</option>
                            <option value="iphonese">iPhone SE (750x1334)</option>
                        </optgroup>
                        <optgroup label="é€šç”¨å°ºå¯¸" data-i18n="wp.device.group.common">
                            <option value="fhd" data-i18n="wp.device.fhd">FHD (1080x1920)</option>
                            <option value="qhd" data-i18n="wp.device.qhd">QHD (1440x2560)</option>
                            <option value="4k" data-i18n="wp.device.4k">4K (2160x3840)</option>
                        </optgroup>
                    </select>
                </section>

                <!-- Scale Control -->
                <section id="wallpaperScaleSection" class="hidden">
                    <div class="space-y-2">
                        <div class="flex justify-between">
                            <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                                data-i18n="wp.scale">ç¼©æ”¾</label>
                            <span id="wallpaperScaleVal" class="text-xs text-gray-500">100%</span>
                        </div>
                        <input type="range" id="wallpaperScaleRange" min="50" max="500" value="100"
                            class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
                    </div>
                </section>

                <!-- Reset Position Button -->
                <section id="wallpaperResetSection" class="hidden">
                    <button id="wallpaperResetBtn"
                        class="w-full py-2 border border-gray-200 dark:border-slate-700 rounded-lg text-sm font-medium text-gray-600 dark:text-slate-300 hover:bg-gray-50 dark:hover:bg-slate-800 transition-colors">
                        <i class="fa-solid fa-arrows-to-dot mr-2"></i><span data-i18n="wp.btn.reset">é‡ç½®ä½ç½®</span>
                    </button>
                </section>
            </div>

            <!-- Export Quality (Common) -->
            <section class="pt-4 border-t border-gray-200 dark:border-slate-800">
                <div class="space-y-2">
                    <div class="flex justify-between">
                        <label class="text-xs font-medium text-gray-500 dark:text-slate-400 uppercase"
                            data-i18n="quality.label">å¯¼å‡ºè´¨é‡</label>
                        <span id="wallpaperQualityVal" class="text-xs text-gray-500">90%</span>
                    </div>
                    <input type="range" id="wallpaperQuality" min="10" max="100" value="90"
                        class="w-full h-2 bg-gray-200 dark:bg-slate-800 rounded-lg appearance-none cursor-pointer accent-violet-600">
                </div>
            </section>

            <!-- Download Button -->
            <section>
                <button id="wallpaperDownloadBtn" disabled
                    class="w-full py-4 bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white rounded-xl font-medium shadow-lg shadow-violet-600/30 transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                    </svg>
                    <span data-i18n="wp.btn.download">ä¸‹è½½å£çº¸</span>
                </button>
            </section>
        </div>
    </aside>

    <!-- Main Content Area -->
    <main
        class="flex-1 bg-gray-100 dark:bg-slate-950/50 relative flex flex-col items-center justify-center p-4 md:p-8 overflow-hidden min-h-[400px] md:min-h-0">

        <!-- Puzzle Main -->
        <div id="puzzle-main" class="w-full h-full flex items-center justify-center relative">
            <div class="absolute inset-0 opacity-10 dark:opacity-5 pointer-events-none"
                style="background-image: radial-gradient(#cbd5e1 1px, transparent 1px); background-size: 20px 20px;">
            </div>
            <div id="puzzleEmptyState" class="text-center relative z-10">
                <div
                    class="w-32 h-32 bg-white dark:bg-slate-900 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm text-gray-300 dark:text-slate-500">
                    <svg class="w-16 h-16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="3" y="3" width="18" height="18" rx="4" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round" />
                        <circle cx="8.5" cy="8.5" r="1.5" fill="currentColor" />
                        <path d="M21 15L16 10L5 21" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round" />
                    </svg>
                </div>
                <h3 class="text-2xl font-bold text-gray-700 dark:text-gray-200 mb-2" data-i18n="empty.title">æœªé€‰æ‹©å›¾ç‰‡</h3>
                <p class="text-gray-500 dark:text-slate-400 text-lg" data-i18n="empty.desc">è¯·ä¸Šä¼ å›¾ç‰‡å¼€å§‹åˆ¶ä½œ</p>
            </div>

            <div id="canvasContainer" class="relative shadow-2xl transition-all duration-300 bg-white hidden"
                style="width: 100%; height: 100%;">
                <div id="gridContainer" class="w-full h-full grid gap-0 overflow-hidden">
                    <!-- Grid cells will be injected here -->
                </div>
            </div>
            <div class="absolute bottom-6 left-1/2 transform -translate-x-1/2 bg-black/70 text-white px-4 py-2 rounded-full text-sm backdrop-blur-sm pointer-events-none opacity-0 transition-opacity duration-300"
                id="interactionHint" data-i18n="empty.hint">
                æ‹–æ‹½ç§»åŠ¨å›¾ç‰‡ â€¢ æ»šè½®ç¼©æ”¾
            </div>
        </div>

        <!-- Frame Main -->
        <div id="frame-main" class="hidden w-full h-full relative">
            <div class="absolute inset-0 opacity-10 dark:opacity-5 pointer-events-none"
                style="background-image: radial-gradient(#cbd5e1 1px, transparent 1px); background-size: 20px 20px;">
            </div>
            <div id="frameEmptyState" class="absolute inset-0 flex flex-col items-center justify-center z-10">
                <div
                    class="w-32 h-32 bg-white dark:bg-slate-900 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm text-gray-300 dark:text-slate-500">
                    <svg class="w-16 h-16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="3" y="3" width="18" height="18" rx="4" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round" />
                        <circle cx="8.5" cy="8.5" r="1.5" fill="currentColor" />
                        <path d="M21 15L16 10L5 21" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round" />
                    </svg>
                </div>
                <h3 class="text-2xl font-bold text-gray-700 dark:text-gray-200 mb-2" data-i18n="empty.title">æœªé€‰æ‹©å›¾ç‰‡</h3>
                <p class="text-gray-500 dark:text-slate-400 text-lg" data-i18n="empty.desc">è¯·ä¸Šä¼ å›¾ç‰‡å¼€å§‹åˆ¶ä½œ</p>
            </div>
            <div id="frameGallery"
                class="w-full h-full overflow-y-auto custom-scrollbar grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6 pb-12">
            </div>
        </div>

        <!-- Watermark Main -->
        <div id="watermark-main"
            class="hidden w-full h-full flex items-center justify-center relative p-8 overflow-hidden">
            <div class="absolute inset-0 opacity-10 dark:opacity-5 pointer-events-none"
                style="background-image: radial-gradient(#cbd5e1 1px, transparent 1px); background-size: 20px 20px;">
            </div>

            <div id="wmEmptyState" class="text-center relative z-10">
                <div
                    class="w-32 h-32 bg-white dark:bg-slate-900 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm text-gray-300 dark:text-slate-500">
                    <svg class="w-16 h-16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="3" y="3" width="18" height="18" rx="4" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round" />
                        <circle cx="8.5" cy="8.5" r="1.5" fill="currentColor" />
                        <path d="M21 15L16 10L5 21" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round" />
                    </svg>
                </div>
                <h3 class="text-2xl font-bold text-gray-700 dark:text-gray-200 mb-2" data-i18n="empty.title">æœªé€‰æ‹©å›¾ç‰‡</h3>
                <p class="text-gray-500 dark:text-slate-400 text-lg" data-i18n="empty.desc">è¯·ä¸Šä¼ å›¾ç‰‡å¼€å§‹åˆ¶ä½œ</p>
            </div>

            <canvas id="wmMainCanvas"
                class="hidden shadow-2xl rounded-sm cursor-crosshair max-w-full max-h-full object-contain bg-white relative z-10"></canvas>
        </div>

        <!-- Tag Master Main -->
        <div id="tag-main" class="hidden w-full h-full flex items-center justify-center relative p-8">
            <div class="absolute inset-0 pointer-events-none dotted-grid"></div>

            <!-- Empty State -->
            <div id="tagEmptyState" class="text-center relative z-10">
                <div
                    class="w-32 h-32 bg-white dark:bg-slate-900 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm text-gray-300 dark:text-slate-500">
                    <svg class="w-16 h-16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="3" y="3" width="18" height="18" rx="4" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round" />
                        <circle cx="8.5" cy="8.5" r="1.5" fill="currentColor" />
                        <path d="M21 15L16 10L5 21" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round" />
                    </svg>
                </div>
                <h3 class="text-2xl font-bold text-gray-700 dark:text-gray-200 mb-2" data-i18n="empty.title">æœªé€‰æ‹©å›¾ç‰‡</h3>
                <p class="text-gray-500 dark:text-slate-400 text-lg" data-i18n="empty.desc">è¯·ä¸Šä¼ å›¾ç‰‡å¼€å§‹åˆ¶ä½œ</p>
            </div>

            <!-- Grid Container -->
            <div id="tagGridContainer" class="hidden w-full h-full overflow-y-auto custom-scrollbar p-8 relative z-20">
                <div id="tagGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 pb-24">
                    <!-- Image Cards will be injected here -->
                </div>
            </div>
        </div>

        <!-- Content Master Main -->
        <div id="content-main" class="hidden w-full h-full flex items-center justify-center relative p-8">
            <div class="absolute inset-0 pointer-events-none dotted-grid"></div>

            <!-- Empty State -->
            <div id="contentEmptyState" class="text-center relative z-10">
                <div
                    class="w-32 h-32 bg-white dark:bg-slate-900 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm text-gray-300 dark:text-slate-500">
                    <svg class="w-16 h-16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="3" y="3" width="18" height="18" rx="4" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round" />
                        <circle cx="8.5" cy="8.5" r="1.5" fill="currentColor" />
                        <path d="M21 15L16 10L5 21" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round" />
                    </svg>
                </div>
                <h3 class="text-2xl font-bold text-gray-700 dark:text-gray-200 mb-2" data-i18n="empty.title">æœªé€‰æ‹©å›¾ç‰‡</h3>
                <p class="text-gray-500 dark:text-slate-400 text-lg" data-i18n="empty.desc">è¯·ä¸Šä¼ å›¾ç‰‡å¼€å§‹åˆ¶ä½œ</p>
            </div>

            <!-- Content Container -->
            <div id="contentContainer" class="hidden w-full h-full overflow-y-auto custom-scrollbar relative z-20">
                <div class="max-w-4xl mx-auto space-y-6 pb-24">
                    <!-- Image Preview -->
                    <div class="bg-white dark:bg-slate-900 rounded-2xl shadow-lg overflow-hidden">
                        <div class="aspect-video bg-gray-100 dark:bg-slate-950 flex items-center justify-center">
                            <img id="contentPreviewImage" class="max-w-full max-h-full object-contain" />
                        </div>
                    </div>

                    <!-- Generated Title -->
                    <div class="bg-white dark:bg-slate-900 rounded-2xl shadow-lg p-6">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200">
                                <i class="fa-solid fa-heading text-blue-500 mr-2"></i>æ ‡é¢˜
                            </h3>
                            <button id="contentCopyTitleBtn"
                                class="px-3 py-1.5 text-xs border border-gray-200 dark:border-slate-700 rounded-lg text-gray-500 dark:text-slate-400 hover:text-blue-500 hover:border-violet-500 transition-colors">
                                <i class="fa-solid fa-copy"></i> å¤åˆ¶
                            </button>
                        </div>
                        <div id="contentTitleDisplay"
                            class="text-xl font-medium text-gray-700 dark:text-slate-300 min-h-[60px] flex items-center">
                            <span class="text-gray-400 italic">ç­‰å¾…ç”Ÿæˆ...</span>
                        </div>
                    </div>

                    <!-- Generated Content -->
                    <div class="bg-white dark:bg-slate-900 rounded-2xl shadow-lg p-6">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200">
                                <i class="fa-solid fa-align-left text-blue-500 mr-2"></i>æ­£æ–‡
                            </h3>
                            <div class="flex gap-2">
                                <button id="contentCopyContentBtn"
                                    class="px-3 py-1.5 text-xs border border-gray-200 dark:border-slate-700 rounded-lg text-gray-500 dark:text-slate-400 hover:text-blue-500 hover:border-violet-500 transition-colors">
                                    <i class="fa-solid fa-copy"></i> å¤åˆ¶
                                </button>
                                <button id="contentCopyAllBtn"
                                    class="px-3 py-1.5 text-xs bg-violet-500 hover:bg-violet-600 text-white rounded-lg transition-colors">
                                    <i class="fa-solid fa-copy"></i> å¤åˆ¶å…¨éƒ¨
                                </button>
                            </div>
                        </div>
                        <div id="contentTextDisplay"
                            class="text-gray-700 dark:text-slate-300 whitespace-pre-wrap min-h-[200px]">
                            <span class="text-gray-400 italic">ç­‰å¾…ç”Ÿæˆ...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Wallpaper Master Main -->
        <div id="wallpaper-main" class="hidden w-full h-full relative">
            <div class="absolute inset-0 opacity-10 dark:opacity-5 pointer-events-none"
                style="background-image: radial-gradient(#cbd5e1 1px, transparent 1px); background-size: 20px 20px;">
            </div>

            <!-- Inner container for centering content -->
            <div class="w-full h-full flex items-center justify-center p-8">
                <!-- Empty State -->
                <div id="wallpaperEmptyState" class="text-center relative z-10">
                    <div
                        class="w-32 h-32 bg-white dark:bg-slate-900 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm text-gray-300 dark:text-slate-500">
                        <svg class="w-16 h-16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <rect x="3" y="3" width="18" height="18" rx="4" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round" />
                            <circle cx="8.5" cy="8.5" r="1.5" fill="currentColor" />
                            <path d="M21 15L16 10L5 21" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" />
                        </svg>
                    </div>
                    <h3 class="text-2xl font-bold text-gray-700 dark:text-gray-200 mb-2" data-i18n="wp.empty.title">
                        æœªç”Ÿæˆå£çº¸</h3>
                    <p class="text-gray-500 dark:text-slate-400 text-lg" data-i18n="wp.empty.desc">é€‰æ‹©AIç”Ÿæˆæˆ–ä¸Šä¼ è‡ªå®šä¹‰å›¾ç‰‡</p>
                </div>

                <!-- Canvas for Custom Image -->
                <div id="wallpaperCanvasContainer" class="hidden relative">
                    <canvas id="wallpaperCanvas"
                        class="shadow-2xl rounded-lg cursor-move max-w-full max-h-full bg-white dark:bg-slate-900"></canvas>
                    <div id="wallpaperCanvasHint"
                        class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black/70 text-white px-4 py-2 rounded-full text-sm backdrop-blur-sm pointer-events-none opacity-0 transition-opacity duration-300"
                        data-i18n="empty.hint">
                        æ‹–æ‹½ç§»åŠ¨ â€¢ æ»šè½®ç¼©æ”¾
                    </div>
                </div>

                <!-- AI Generated Wallpaper Preview -->
                <div id="wallpaperPreviewContainer" class="hidden relative w-full h-full">
                    <img id="wallpaperPreviewImage" class="w-full h-full object-contain" />
                    <div id="wallpaperLoadingOverlay"
                        class="absolute inset-0 bg-white/80 dark:bg-slate-950/80 backdrop-blur-md flex items-center justify-center rounded-lg">
                        <div class="text-center bg-white dark:bg-slate-900 rounded-2xl shadow-2xl p-8 max-w-xs">
                            <!-- Elegant spinner -->
                            <div class="relative w-20 h-20 mx-auto mb-6">
                                <div
                                    class="absolute inset-0 border-4 border-blue-200 dark:border-blue-900 rounded-full">
                                </div>
                                <div
                                    class="absolute inset-0 border-4 border-transparent border-t-blue-600 dark:border-t-blue-400 rounded-full animate-spin">
                                </div>
                            </div>
                            <p id="wallpaperLoadingText" class="text-base font-medium text-gray-800 dark:text-gray-200"
                                data-i18n="wp.loading">
                                æ­£åœ¨ç”Ÿæˆå£çº¸...</p>
                            <p class="text-sm text-gray-500 dark:text-slate-400 mt-2" data-i18n="wp.wait">è¯·ç¨å€™</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- API Settings Modal -->
        <div id="tagApiModal"
            class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div class="bg-white dark:bg-slate-900 rounded-2xl shadow-2xl max-w-md w-full max-h-[90vh] overflow-y-auto">
                <div class="p-6 space-y-6">
                    <!-- Header -->
                    <div class="flex justify-between items-center">
                        <h2 class="text-xl font-bold text-gray-800 dark:text-gray-200" data-i18n="setting.title">AI
                            APIè®¾ç½®</h2>
                        <button id="tagApiModalClose"
                            class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-800 transition-colors text-gray-600 dark:text-slate-300">
                            <i class="fa-solid fa-xmark text-xl"></i>
                        </button>
                    </div>

                    <!-- Form -->
                    <div class="space-y-4">
                        <!-- Vision Model Section -->
                        <div class="border-b border-gray-200 dark:border-slate-800 pb-4">
                            <h3 class="text-sm font-semibold text-gray-700 dark:text-slate-300 mb-3 flex items-center">
                                <i class="fa-solid fa-eye mr-2 text-blue-500"></i>
                                <span data-i18n="setting.vision_section">è§†è§‰æ¨¡å‹ (æ ‡ç­¾/æ–‡æ¡ˆå¤§å¸ˆ)</span>
                            </h3>

                            <!-- Provider -->
                            <div class="space-y-2 mb-3">
                                <label class="text-sm font-medium text-gray-700 dark:text-slate-300"
                                    data-i18n="setting.provider">API æä¾›å•†</label>
                                <select id="tagApiProvider"
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                                    <option value="openai" data-i18n="setting.provider.openai">OpenAI (GPT-4 Vision)
                                    </option>
                                    <option value="gemini" data-i18n="setting.provider.gemini">Google Gemini</option>
                                    <option value="custom" data-i18n="setting.provider.custom">è‡ªå®šä¹‰</option>
                                </select>
                            </div>

                            <!-- API Endpoint -->
                            <div class="space-y-2 mb-3">
                                <label class="text-sm font-medium text-gray-700 dark:text-slate-300">API ç«¯ç‚¹</label>
                                <input type="text" id="tagApiEndpoint"
                                    placeholder="https://api.openai.com/v1/chat/completions"
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                            </div>

                            <!-- API Key -->
                            <div class="space-y-2 mb-3">
                                <label class="text-sm font-medium text-gray-700 dark:text-slate-300">API å¯†é’¥</label>
                                <input type="password" id="tagApiKey" placeholder="sk-..."
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                            </div>

                            <!-- Model Name -->
                            <div class="space-y-2">
                                <label class="text-sm font-medium text-gray-700 dark:text-slate-300">æ¨¡å‹åç§°</label>
                                <input type="text" id="tagModelName" placeholder="gpt-4-vision-preview"
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                            </div>
                        </div>

                        <!-- Text Generation Model Section -->
                        <div class="border-b border-gray-200 dark:border-slate-800 pb-4">
                            <h3 class="text-sm font-semibold text-gray-700 dark:text-slate-300 mb-3 flex items-center">
                                <i class="fa-solid fa-comment-dots mr-2 text-green-500"></i>
                                æ–‡æœ¬ç”Ÿæˆæ¨¡å‹ (å£çº¸Promptç”Ÿæˆ)
                            </h3>

                            <!-- Text Model Endpoint -->
                            <div class="space-y-2 mb-3">
                                <label class="text-sm font-medium text-gray-700 dark:text-slate-300">API ç«¯ç‚¹</label>
                                <input type="text" id="textModelEndpoint"
                                    placeholder="https://api.openai.com/v1/chat/completions"
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                            </div>

                            <!-- Text Model Key -->
                            <div class="space-y-2 mb-3">
                                <label class="text-sm font-medium text-gray-700 dark:text-slate-300"
                                    data-i18n="setting.key">API å¯†é’¥</label>
                                <input type="password" id="textModelKey" placeholder="sk-..."
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                            </div>

                            <!-- Text Model Name -->
                            <div class="space-y-2">
                                <label class="text-sm font-medium text-gray-700 dark:text-slate-300"
                                    data-i18n="setting.model_name">æ¨¡å‹åç§°</label>
                                <input type="text" id="textModelName" placeholder="gpt-4"
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                            </div>
                        </div>

                        <!-- Image Generation Model Section -->
                        <div class="pb-2">
                            <h3 class="text-sm font-semibold text-gray-700 dark:text-slate-300 mb-3 flex items-center">
                                <i class="fa-solid fa-image mr-2 text-purple-500"></i>
                                <span data-i18n="setting.image_section">å›¾åƒç”Ÿæˆæ¨¡å‹ (å£çº¸ç”Ÿæˆ)</span>
                            </h3>

                            <!-- Image Gen Endpoint -->
                            <div class="space-y-2 mb-3">
                                <label class="text-sm font-medium text-gray-700 dark:text-slate-300"
                                    data-i18n="setting.endpoint">API ç«¯ç‚¹</label>
                                <input type="text" id="imageGenEndpoint"
                                    placeholder="https://api.openai.com/v1/images/generations"
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                            </div>

                            <!-- Image Gen Key -->
                            <div class="space-y-2 mb-3">
                                <label class="text-sm font-medium text-gray-700 dark:text-slate-300"
                                    data-i18n="setting.key">API å¯†é’¥</label>
                                <input type="password" id="imageGenKey" placeholder="sk-..."
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                            </div>

                            <!-- Image Gen Model Name -->
                            <div class="space-y-2">
                                <label class="text-sm font-medium text-gray-700 dark:text-slate-300"
                                    data-i18n="setting.model_name">æ¨¡å‹åç§°</label>
                                <input type="text" id="imageGenModelName" placeholder="dall-e-3"
                                    class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-sm focus:ring-2 focus:ring-blue-600 outline-none dark:text-gray-200">
                            </div>
                        </div>
                    </div>

                    <!-- Actions -->
                    <div class="flex gap-3">
                        <button id="tagApiTest"
                            class="flex-1 py-2.5 border border-gray-200 dark:border-slate-700 rounded-lg text-sm font-medium text-gray-700 dark:text-slate-300 hover:bg-gray-50 dark:hover:bg-slate-800 transition-colors">
                            <span data-i18n="setting.btn.test">æµ‹è¯•è¿æ¥</span>
                        </button>
                        <button id="tagApiSave"
                            class="flex-1 py-2.5 bg-gradient-to-r from-violet-600 to-indigo-600 hover:from-violet-700 hover:to-indigo-700 text-white rounded-lg text-sm font-medium transition-colors">
                            <span data-i18n="setting.btn.save">ä¿å­˜è®¾ç½®</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Toast -->
        <div id="statusMsg"
            class="fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-gray-900/90 backdrop-blur-md text-white px-6 py-3 rounded-full shadow-lg z-50 hidden flex items-center gap-3 transition-all duration-300 translate-y-10 opacity-0">
            <svg class="animate-spin h-5 w-5 text-blue-500 hidden" xmlns="http://www.w3.org/2000/svg" fill="none"
                viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                </path>
            </svg>
            <span id="statusText" class="text-sm font-medium tracking-wide" data-i18n="status.processing">å¤„ç†ä¸­...</span>
        </div>

    </main>

    <script>
        // --- Internationalization ---
        const appTranslations = {
            "zh-CN": {
                "title": "å½±åƒå¤§å¸ˆ",
                "brand": "å½±åƒå¤§å¸ˆ",
                "setting.api": "AI API è®¾ç½®",
                "setting.title": "AI API è®¾ç½®",
                "setting.vision_section": "è§†è§‰æ¨¡å‹ (æ ‡ç­¾/æ–‡æ¡ˆå¤§å¸ˆ)",
                "setting.provider": "API æä¾›å•†",
                "setting.provider.openai": "OpenAI (GPT-4 Vision)",
                "setting.provider.gemini": "Google Gemini",
                "setting.provider.custom": "è‡ªå®šä¹‰",
                "setting.text_section": "æ–‡æœ¬ç”Ÿæˆæ¨¡å‹ (Tag/Content)",
                "setting.image_section": "å›¾åƒç”Ÿæˆæ¨¡å‹ (å£çº¸ç”Ÿæˆ)",
                "setting.key": "API å¯†é’¥",
                "setting.model_name": "æ¨¡å‹åç§°",
                "setting.endpoint": "API ç«¯ç‚¹",
                "setting.btn.test": "æµ‹è¯•è¿æ¥",
                "setting.btn.save": "ä¿å­˜è®¾ç½®",
                "status.processing": "å¤„ç†ä¸­...",
                "tab.puzzle": "æ‹¼å›¾å¤§å¸ˆ",
                "tab.frame": "è¾¹æ¡†å¤§å¸ˆ",
                "tab.watermark": "æ°´å°å¤§å¸ˆ",
                "tab.tag": "æ ‡ç­¾å¤§å¸ˆ",
                "tab.content": "æ–‡æ¡ˆå¤§å¸ˆ",
                "tab.wallpaper": "å£çº¸å¤§å¸ˆ",

                // Common
                "upload.title": "å›¾ç‰‡ä¸Šä¼ ",
                "upload.desc": "ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å›¾ç‰‡",
                "upload.drag": "ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å›¾ç‰‡",
                "upload.sub": "æ”¯æŒæœ€å¤š300å¼ å›¾ç‰‡",
                "upload.batch": "æ”¯æŒæ‰¹é‡å¤„ç†",
                "upload.single": "æ”¯æŒå•å¼ å›¾ç‰‡",
                "quality.label": "å¯¼å‡ºè´¨é‡",
                "btn.download": "ä¸‹è½½å›¾ç‰‡",
                "btn.download_all": "æ‰“åŒ…ä¸‹è½½å…¨éƒ¨",
                "btn.generate": "å¼€å§‹ç”Ÿæˆ",
                "btn.retry": "é‡è¯•",
                "btn.copied": "å·²å¤åˆ¶",
                "tag.no_tags": "æ²¡æœ‰å¯å¤åˆ¶çš„æ ‡ç­¾",

                // Puzzle
                "puzzle.layout": "é€‰æ‹©ç‰ˆå¼",
                "puzzle.ratio": "ç”»å¸ƒæ¯”ä¾‹",
                "puzzle.border": "è¾¹æ¡†è®¾ç½®",
                "puzzle.border.width": "ç²—ç»†",
                "puzzle.border.color": "é¢œè‰²",
                "puzzle.custom": "è‡ªå®šä¹‰",
                "puzzle.layout.2_v": "å·¦å³åˆ†å±",
                "puzzle.layout.2_h": "ä¸Šä¸‹åˆ†å±",
                "puzzle.layout.3_grid_l": "å·¦1å³2",
                "puzzle.layout.3_grid_r": "å·¦2å³1",
                "puzzle.layout.3_v": "ä¸‰åˆ—å¹¶æ’",
                "puzzle.layout.3_h": "ä¸‰è¡Œå¹¶æ’",
                "puzzle.layout.3_hero_top": "é¡¶éƒ¨å¤§å›¾",
                "puzzle.layout.3_hero_bottom": "åº•éƒ¨å¤§å›¾",
                "puzzle.layout.4_grid": "ç”°å­—æ ¼",
                "puzzle.layout.4_v": "å››åˆ—å¹¶æ’",
                "puzzle.layout.4_h": "å››è¡Œå¹¶æ’",
                "puzzle.layout.4_hero_top": "é¡¶éƒ¨å¤§å›¾",
                "puzzle.layout.4_hero_left": "å·¦ä¾§å¤§å›¾",
                "puzzle.layout.default": "é»˜è®¤",
                "puzzle.layout.5_v": "äº”åˆ—å¹¶æ’",
                "puzzle.layout.5_h": "äº”è¡Œå¹¶æ’",
                "puzzle.layout.5_mosaic_l": "å·¦ä¾§æ‹¼è´´",
                "puzzle.layout.5_hero_top": "é¡¶éƒ¨å¤§å›¾",
                "puzzle.layout.6_grid_3x2": "3x2",
                "puzzle.layout.6_grid_2x3": "2x3",
                "puzzle.layout.6_v": "å…­åˆ—å¹¶æ’",
                "puzzle.layout.6_h": "å…­è¡Œå¹¶æ’",
                "puzzle.layout.6_corner": "è§’è½ç„¦ç‚¹",
                "puzzle.layout.7_v": "ä¸ƒåˆ—å¹¶æ’",
                "puzzle.layout.7_h": "ä¸ƒè¡Œå¹¶æ’",
                "puzzle.layout.7_hero_top": "é¡¶éƒ¨å¤§å›¾",
                "puzzle.layout.8_grid_4x2": "4x2",
                "puzzle.layout.8_grid_2x4": "2x4",
                "puzzle.layout.8_v": "å…«åˆ—å¹¶æ’",
                "puzzle.layout.8_h": "å…«è¡Œå¹¶æ’",
                "puzzle.layout.8_hero_top_2": "é¡¶éƒ¨åŒå›¾",
                "puzzle.layout.9_grid_3x3": "3x3",
                "puzzle.layout.9_v": "ä¹åˆ—å¹¶æ’",
                "puzzle.layout.9_h": "ä¹è¡Œå¹¶æ’",
                "puzzle.layout.9_center": "ä¸­å¿ƒå¤§å›¾",
                "puzzle.layout.10_grid_5x2": "5x2",
                "puzzle.layout.10_v": "ååˆ—å¹¶æ’",
                "puzzle.layout.10_h": "åè¡Œå¹¶æ’",
                "puzzle.layout.11_v": "11åˆ—å¹¶æ’",
                "puzzle.layout.11_h": "11è¡Œå¹¶æ’",
                "puzzle.layout.12_grid_4x3": "4x3",
                "puzzle.layout.12_grid_3x4": "3x4",
                "puzzle.layout.12_v": "12åˆ—å¹¶æ’",
                "puzzle.layout.12_h": "12è¡Œå¹¶æ’",

                // Frame
                "frame.type": "è¾¹æ¡†ç±»å‹",
                "frame.type.blur": "æ¨¡ç³ŠèƒŒæ™¯",
                "frame.type.solid": "çº¯è‰²è¾¹æ¡†",
                "frame.type.gradient": "æ¸å˜èƒŒæ™¯",
                "frame.type.matte": "åŒå±‚å¡çº¸",
                "frame.color": "è¾¹æ¡†é¢œè‰²",
                "frame.params": "å‚æ•°è°ƒæ•´",
                "frame.param.width": "è¾¹æ¡†å®½åº¦",
                "frame.param.blur": "èƒŒæ™¯æ¨¡ç³Š",
                "frame.param.font": "æ–‡å­—å¤§å°",
                "frame.exif": "æ˜¾ç¤ºæ‹æ‘„å‚æ•° (EXIF)",

                // Watermark
                "wm.upload.sub": "æ”¯æŒå¤šç§æ°´å°åŠŸèƒ½",
                "wm.type.image": "å›¾ç‰‡",
                "wm.type.text": "æ–‡å­—",
                "wm.type.palette": "è‰²å¡",
                "wm.type.histogram": "ç›´æ–¹å›¾",
                "wm.btn.upload": "ä¸Šä¼ æ°´å°å›¾",
                "wm.text.content": "ç­¾åå†…å®¹",
                "wm.text.placeholder": "è¾“å…¥ç­¾å...",
                "wm.text.font": "å­—ä½“é£æ ¼",
                "wm.text.color": "é¢œè‰²",
                "wm.btn.add": "ç”Ÿæˆå¹¶æ·»åŠ ",
                "wm.btn.save": "ä¿å­˜é¢„è®¾",
                "wm.btn.export": "å¯¼å‡ºPNG",
                "wm.palette.count": "é¢œè‰²æ•°é‡",
                "wm.palette.style": "æ ·å¼",
                "wm.palette.circle": "åœ†å½¢",
                "wm.palette.square": "æ–¹å½¢",
                "wm.palette.strip": "é•¿æ¡",
                "wm.btn.generate_palette": "ç”Ÿæˆè‰²å¡",
                "wm.btn.generate_histogram": "ç”Ÿæˆç›´æ–¹å›¾",
                "wm.histogram.rgb": "RGB é‡å ",
                "wm.histogram.luminance": "äº®åº¦ (ç™½è‰²)",
                "wm.histogram.color": "å½©è‰²åˆ†å¸ƒ",
                "wm.pos": "ä½ç½®é¢„è®¾",
                "wm.size": "å¤§å°",
                "wm.opacity": "ä¸é€æ˜åº¦",

                // Tag
                "tag.settings": "æ ‡ç­¾è®¾ç½®",
                "tag.count": "æ ‡ç­¾æ•°é‡",
                "tag.lang": "æ ‡ç­¾è¯­è¨€",
                "tag.lang.auto": "è‡ªåŠ¨æ£€æµ‹",
                "tag.lang.zh": "ä¸­æ–‡",
                "tag.lang.en": "English",
                "tag.btn.generate": "ç”Ÿæˆæ ‡ç­¾",
                "tag.batch": "æ‰¹é‡æ“ä½œ",
                "tag.btn.clear": "æ¸…ç©ºå†å²",
                "tag.btn.copy": "å¤åˆ¶å…¨éƒ¨ç»“æœ",
                "tag.hint": "å·²ç”Ÿæˆæ ‡ç­¾çš„å›¾ç‰‡ç»“æœå°†æ˜¾ç¤ºåœ¨å³ä¾§ç½‘æ ¼ä¸­ã€‚",

                // Content
                "content.info": "è¡¥å……ä¿¡æ¯",
                "content.optional": "(å¯é€‰)",
                "content.style": "æ–‡æ¡ˆé£æ ¼",
                "content.placeholder": "è¾“å…¥å…³é”®è¯ã€äº§å“ä¿¡æ¯æˆ–æƒ³è¦è¡¨è¾¾çš„å†…å®¹...",
                "content.style.general": "é€šç”¨",
                "content.style.zhongcao": "ç§è‰",
                "content.style.photography": "æ‘„å½±",
                "content.style.tutorial": "æ•™ç¨‹",
                "content.style.daily": "æ—¥å¸¸",
                "content.btn.generate": "ç”Ÿæˆæ–‡æ¡ˆ",
                "content.title": "æ ‡é¢˜",
                "content.body": "æ­£æ–‡",
                "content.btn.copy": "å¤åˆ¶",
                "content.btn.copy_all": "å¤åˆ¶å…¨éƒ¨",
                "content.waiting": "ç­‰å¾…ç”Ÿæˆ...",

                // Wallpaper
                "wp.mode.ai": "AIç”Ÿæˆ",
                "wp.mode.custom": "è‡ªå®šä¹‰å›¾ç‰‡",
                "wp.style": "å£çº¸é£æ ¼",
                "wp.style.nature": "è‡ªç„¶é£å…‰",
                "wp.style.cityscape": "åŸå¸‚é£å…‰",
                "wp.style.abstract": "æŠ½è±¡è‰ºæœ¯",
                "wp.style.minimalist": "æç®€ä¸»ä¹‰",
                "wp.style.anime": "åŠ¨æ¼«äºŒæ¬¡å…ƒ",
                "wp.style.space": "å®‡å®™æ˜Ÿç©º",
                "wp.style.gradient": "æ¸å˜è‰²å½©",
                "wp.style.pattern": "å‡ ä½•å›¾æ¡ˆ",
                "wp.ratio": "å°ºå¯¸æ¯”ä¾‹",
                "wp.ratio.16_9": "16:9 æ¨ªå± (1664Ã—928)",
                "wp.ratio.4_3": "4:3 æ¨ªå± (1472Ã—1140)",
                "wp.ratio.1_1": "1:1 æ­£æ–¹å½¢ (1328Ã—1328)",
                "wp.ratio.3_4": "3:4 ç«–å± (1140Ã—1472)",
                "wp.ratio.9_16": "9:16 ç«–å± (928Ã—1664)",
                "wp.btn.generate": "ç”Ÿæˆå£çº¸",
                "wp.btn.download": "ä¸‹è½½å£çº¸",
                "wp.device": "è®¾å¤‡å°ºå¯¸",
                "wp.device.group.iphone": "iPhone",
                "wp.device.group.common": "é€šç”¨å°ºå¯¸",
                "wp.device.fhd": "FHD (1080x1920)",
                "wp.device.qhd": "QHD (1440x2560)",
                "wp.device.4k": "4K (2160x3840)",
                "wp.scale": "ç¼©æ”¾",
                "wp.btn.reset": "é‡ç½®ä½ç½®",
                "wp.empty.title": "æœªç”Ÿæˆå£çº¸",
                "wp.empty.desc": "é€‰æ‹©AIç”Ÿæˆæˆ–ä¸Šä¼ è‡ªå®šä¹‰å›¾ç‰‡",
                "wp.loading": "æ­£åœ¨ç”Ÿæˆå£çº¸...",
                "wp.wait": "è¯·ç¨å€™",
                "wp.drag.hint": "æ”¯æŒæ‹–æ‹½ç¼©æ”¾è°ƒæ•´",

                // Empty States
                "empty.title": "æœªé€‰æ‹©å›¾ç‰‡",
                "empty.desc": "è¯·ä¸Šä¼ å›¾ç‰‡å¼€å§‹åˆ¶ä½œ",
                "empty.hint": "æ‹–æ‹½ç§»åŠ¨å›¾ç‰‡ â€¢ æ»šè½®ç¼©æ”¾"
            },
            "en-US": {
                "title": "Image Master",
                "brand": "Image Master",
                "setting.api": "AI API Settings",
                "setting.title": "AI API Settings",
                "setting.vision_section": "Vision Model (Tag/Content)",
                "setting.provider": "API Provider",
                "setting.provider.openai": "OpenAI (GPT-4 Vision)",
                "setting.provider.gemini": "Google Gemini",
                "setting.provider.custom": "Custom",
                "setting.text_section": "Text Gen Model (Tag/Content)",
                "setting.image_section": "Image Gen Model (Wallpaper)",
                "setting.key": "API Key",
                "setting.model_name": "Model Name",
                "setting.endpoint": "API Endpoint",
                "setting.btn.test": "Test Connection",
                "setting.btn.save": "Save Settings",
                "status.processing": "Processing...",
                "tab.puzzle": "Puzzle Master",
                "tab.frame": "Frame Master",
                "tab.watermark": "Watermark Master",
                "tab.tag": "Tag Master",
                "tab.content": "Content Master",
                "tab.wallpaper": "Wallpaper Master",

                // Common
                "upload.title": "Upload Image",
                "upload.desc": "Click or drag to upload",
                "upload.drag": "Click or drag to upload",
                "upload.sub": "Support up to 300 images",
                "upload.batch": "Batch processing supported",
                "upload.single": "Single image supported",
                "quality.label": "Export Quality",
                "btn.download": "Download Image",
                "btn.download_all": "Download All",
                "btn.generate": "Generate",
                "btn.retry": "Retry",
                "btn.copied": "Copied",
                "tag.no_tags": "No tags to copy",

                // Puzzle
                "puzzle.layout": "Select Layout",
                "puzzle.ratio": "Canvas Ratio",
                "puzzle.border": "Border Settings",
                "puzzle.border.width": "Thickness",
                "puzzle.border.color": "Color",
                "puzzle.custom": "Custom",
                "puzzle.layout.2_v": "Side by Side",
                "puzzle.layout.2_h": "Top and Bottom",
                "puzzle.layout.3_grid_l": "Left 1 Right 2",
                "puzzle.layout.3_grid_r": "Left 2 Right 1",
                "puzzle.layout.3_v": "Three Columns",
                "puzzle.layout.3_h": "Three Rows",
                "puzzle.layout.3_hero_top": "Hero Top",
                "puzzle.layout.3_hero_bottom": "Hero Bottom",
                "puzzle.layout.4_grid": "Grid 2x2",
                "puzzle.layout.4_v": "Four Columns",
                "puzzle.layout.4_h": "Four Rows",
                "puzzle.layout.4_hero_top": "Hero Top",
                "puzzle.layout.4_hero_left": "Hero Left",
                "puzzle.layout.default": "Default",
                "puzzle.layout.5_v": "Five Columns",
                "puzzle.layout.5_h": "Five Rows",
                "puzzle.layout.5_mosaic_l": "Mosaic Left",
                "puzzle.layout.5_hero_top": "Hero Top",
                "puzzle.layout.6_grid_3x2": "Grid 3x2",
                "puzzle.layout.6_grid_2x3": "Grid 2x3",
                "puzzle.layout.6_v": "Six Columns",
                "puzzle.layout.6_h": "Six Rows",
                "puzzle.layout.6_corner": "Corner Focus",
                "puzzle.layout.7_v": "Seven Columns",
                "puzzle.layout.7_h": "Seven Rows",
                "puzzle.layout.7_hero_top": "Hero Top",
                "puzzle.layout.8_grid_4x2": "Grid 4x2",
                "puzzle.layout.8_grid_2x4": "Grid 2x4",
                "puzzle.layout.8_v": "Eight Columns",
                "puzzle.layout.8_h": "Eight Rows",
                "puzzle.layout.8_hero_top_2": "Twin Top",
                "puzzle.layout.9_grid_3x3": "Grid 3x3",
                "puzzle.layout.9_v": "Nine Columns",
                "puzzle.layout.9_h": "Nine Rows",
                "puzzle.layout.9_center": "Center Focus",
                "puzzle.layout.10_grid_5x2": "Grid 5x2",
                "puzzle.layout.10_v": "Ten Columns",
                "puzzle.layout.10_h": "Ten Rows",
                "puzzle.layout.11_v": "11 Columns",
                "puzzle.layout.11_h": "11 Rows",
                "puzzle.layout.12_grid_4x3": "Grid 4x3",
                "puzzle.layout.12_grid_3x4": "Grid 3x4",
                "puzzle.layout.12_v": "12 Columns",
                "puzzle.layout.12_h": "12 Rows",

                // Frame
                "frame.type": "Border Type",
                "frame.type.blur": "Blur Background",
                "frame.type.solid": "Solid Color",
                "frame.type.gradient": "Gradient",
                "frame.type.matte": "Matte Frame",
                "frame.color": "Border Color",
                "frame.params": "Parameters",
                "frame.param.width": "Width",
                "frame.param.blur": "Blur",
                "frame.param.font": "Font Size",
                "frame.exif": "Show EXIF Data",

                // Watermark
                "wm.upload.sub": "Various watermark features",
                "wm.type.image": "Image",
                "wm.type.text": "Text",
                "wm.type.palette": "Palette",
                "wm.type.histogram": "Histogram",
                "wm.btn.upload": "Upload Watermark",
                "wm.text.content": "Signature Content",
                "wm.text.placeholder": "Enter signature...",
                "wm.text.font": "Font Style",
                "wm.text.color": "Color",
                "wm.btn.add": "Generate & Add",
                "wm.btn.save": "Save Preset",
                "wm.btn.export": "Export PNG",
                "wm.palette.count": "Color Count",
                "wm.palette.style": "Style",
                "wm.palette.circle": "Circle",
                "wm.palette.square": "Square",
                "wm.palette.strip": "Strip",
                "wm.btn.generate_palette": "Generate Palette",
                "wm.btn.generate_histogram": "Generate Histogram",
                "wm.histogram.rgb": "RGB Overlay",
                "wm.histogram.luminance": "Luminance",
                "wm.histogram.color": "Color Distribution",
                "wm.pos": "Position",
                "wm.size": "Size",
                "wm.opacity": "Opacity",

                // Tag
                "tag.settings": "Tag Settings",
                "tag.count": "Tag Count",
                "tag.lang": "Tag Language",
                "tag.lang.auto": "Auto Detect",
                "tag.lang.zh": "Chinese",
                "tag.lang.en": "English",
                "tag.btn.generate": "Generate Tags",
                "tag.batch": "Batch Actions",
                "tag.btn.clear": "Clear History",
                "tag.btn.copy": "Copy All",
                "tag.hint": "Generated tags will appear in the grid on the right.",

                // Content
                "content.info": "Additional Info",
                "content.optional": "(Optional)",
                "content.style": "Copy Style",
                "content.placeholder": "Enter keywords, product info or content...",
                "content.style.general": "General",
                "content.style.zhongcao": "Marketing",
                "content.style.photography": "Photography",
                "content.style.tutorial": "Tutorial",
                "content.style.daily": "Daily Life",
                "content.btn.generate": "Generate Copy",
                "content.title": "Title",
                "content.body": "Body",
                "content.btn.copy": "Copy",
                "content.btn.copy_all": "Copy All",
                "content.waiting": "Waiting...",

                // Wallpaper
                "wp.mode.ai": "AI Generation",
                "wp.mode.custom": "Custom Image",
                "wp.style": "Wallpaper Style",
                "wp.style.nature": "Nature",
                "wp.style.cityscape": "Cityscape",
                "wp.style.abstract": "Abstract",
                "wp.style.minimalist": "Minimalist",
                "wp.style.anime": "Anime",
                "wp.style.space": "Space",
                "wp.style.gradient": "Gradient",
                "wp.style.pattern": "Geometric",
                "wp.ratio": "Aspect Ratio",
                "wp.ratio.16_9": "16:9 Landscape (1664Ã—928)",
                "wp.ratio.4_3": "4:3 Landscape (1472Ã—1140)",
                "wp.ratio.1_1": "1:1 Square (1328Ã—1328)",
                "wp.ratio.3_4": "3:4 Portrait (1140Ã—1472)",
                "wp.ratio.9_16": "9:16 Portrait (928Ã—1664)",
                "wp.btn.generate": "Generate Wallpaper",
                "wp.btn.download": "Download Wallpaper",
                "wp.device": "Device Size",
                "wp.device.group.iphone": "iPhone",
                "wp.device.group.common": "Universal Size",
                "wp.device.fhd": "FHD (1080x1920)",
                "wp.device.qhd": "QHD (1440x2560)",
                "wp.device.4k": "4K (2160x3840)",
                "wp.scale": "Scale",
                "wp.btn.reset": "Reset Position",
                "wp.empty.title": "No Wallpaper",
                "wp.empty.desc": "Select AI Gen or Upload Image",
                "wp.loading": "Generating Wallpaper...",
                "wp.wait": "Please wait",
                "wp.drag.hint": "Support drag and zoom adjustment",

                // Empty States
                "empty.title": "No Image Selected",
                "empty.desc": "Please upload image to start",
                "empty.hint": "Drag to move â€¢ Scroll to zoom"
            }
        };

        let currentLang = localStorage.getItem('lang') || 'zh-CN';

        function initLanguage() {
            setLanguage(currentLang);

            const toggleBtn = document.getElementById('langToggle');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => {
                    const newLang = currentLang === 'zh-CN' ? 'en-US' : 'zh-CN';
                    setLanguage(newLang);
                });
            }
        }

        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('lang', lang);
            document.documentElement.lang = lang;

            const elements = document.querySelectorAll('[data-i18n]');
            elements.forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (appTranslations[lang] && appTranslations[lang][key]) {
                    if (el.tagName === 'INPUT' && (el.type === 'text' || el.type === 'password')) {
                        el.placeholder = appTranslations[lang][key];
                    } else if (el.tagName === 'TEXTAREA') {
                        el.placeholder = appTranslations[lang][key];
                    } else if (el.tagName === 'OPTGROUP') {
                        el.label = appTranslations[lang][key];
                    } else {
                        // Handle icon inside button (like <i class=".."></i> <span>Text</span>)
                        // If element has valid key, we assume it's the target.
                        // If it has children and only text node should be replaced:
                        if (el.children.length > 0 && el.tagName === 'BUTTON') {
                            // Find the text node or span inside?
                            // Assuming common patterns in app.html:
                            // <button><svg>...</svg> <span>Text</span></button>
                            // If I put data-i18n on the SPAN inside button, I don't need this logic.
                            // But for simple buttons I might have put it on the button itself.
                            // Checking my edits: I put data-i18n on SPANs mostly inside buttons.
                            // So direct replacement is fine.
                            el.innerHTML = el.innerHTML.replace(el.innerText.trim(), appTranslations[lang][key]);
                        } else {
                            el.innerText = appTranslations[lang][key];
                        }
                    }
                }
            });

            // Trigger specific updates for dynamic content
            if (typeof PuzzleApp !== 'undefined' && PuzzleApp.updateAvailableLayouts) {
                PuzzleApp.updateAvailableLayouts();
            }

            updateLangButton();
        }

        function updateLangButton() {
            const btn = document.getElementById('langToggleText');
            if (btn) btn.innerText = currentLang === 'zh-CN' ? 'EN' : 'ä¸­';
        }

        // --- Global Init ---
        function init() {
            initLanguage();
            setupTabs();
            loadTheme();
            AISettings.init();
            PuzzleApp.init();
            FrameApp.init();
            WatermarkApp.init();
            TagMasterApp.init();
            ContentMasterApp.init();
            WallpaperApp.init();
            setupSidebarResize();
        }

        // --- Theme Logic ---
        const themeToggle = document.getElementById('themeToggle');
        themeToggle.addEventListener('click', toggleTheme);

        function toggleTheme() {
            document.documentElement.classList.toggle('dark');
            const theme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
            localStorage.setItem('theme', theme);
            updateThemeIcons(theme);
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            const theme = savedTheme || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
            if (theme === 'dark') document.documentElement.classList.add('dark');
            else document.documentElement.classList.remove('dark');
            updateThemeIcons(theme);
        }

        function updateThemeIcons(theme) {
            const sun = document.getElementById('sunIcon');
            const moon = document.getElementById('moonIcon');
            if (theme === 'dark') {
                sun.classList.remove('hidden');
                moon.classList.add('hidden');
            } else {
                sun.classList.add('hidden');
                moon.classList.remove('hidden');
            }
        }

        // --- Tab Logic ---
        function setupTabs() {
            const tabs = document.querySelectorAll('.tab-btn');
            const puzzleSidebar = document.getElementById('puzzle-sidebar');
            const frameSidebar = document.getElementById('frame-sidebar');
            const puzzleMain = document.getElementById('puzzle-main');
            const frameMain = document.getElementById('frame-main');
            const watermarkSidebar = document.getElementById('watermark-sidebar');
            const watermarkMain = document.getElementById('watermark-main');
            const tagSidebar = document.getElementById('tag-sidebar');
            const tagMain = document.getElementById('tag-main');
            const contentSidebar = document.getElementById('content-sidebar');
            const contentMain = document.getElementById('content-main');
            const wallpaperSidebar = document.getElementById('wallpaper-sidebar');
            const wallpaperMain = document.getElementById('wallpaper-main');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    const target = tab.dataset.tab;

                    // Reset all
                    puzzleSidebar.classList.add('hidden');
                    frameSidebar.classList.add('hidden');
                    watermarkSidebar.classList.add('hidden');
                    tagSidebar.classList.add('hidden');
                    contentSidebar.classList.add('hidden');
                    wallpaperSidebar.classList.add('hidden');

                    puzzleMain.classList.add('hidden');
                    puzzleMain.classList.remove('flex');
                    frameMain.classList.add('hidden');
                    watermarkMain.classList.add('hidden');
                    watermarkMain.classList.remove('flex');
                    tagMain.classList.add('hidden');
                    tagMain.classList.remove('flex');
                    contentMain.classList.add('hidden');
                    contentMain.classList.remove('flex');
                    wallpaperMain.classList.add('hidden');
                    wallpaperMain.classList.remove('flex');

                    if (target === 'puzzle') {
                        puzzleSidebar.classList.remove('hidden');
                        puzzleMain.classList.remove('hidden');
                        puzzleMain.classList.add('flex');
                        setTimeout(PuzzleApp.updateCanvasSize, 50);
                    } else if (target === 'frame') {
                        frameSidebar.classList.remove('hidden');
                        frameMain.classList.remove('hidden');
                    } else if (target === 'watermark') {
                        watermarkSidebar.classList.remove('hidden');
                        watermarkMain.classList.remove('hidden');
                        watermarkMain.classList.add('flex');
                        WatermarkApp.resizeCanvas();
                    } else if (target === 'tag') {
                        tagSidebar.classList.remove('hidden');
                        tagMain.classList.remove('hidden');
                        tagMain.classList.add('flex');
                    } else if (target === 'content') {
                        contentSidebar.classList.remove('hidden');
                        contentMain.classList.remove('hidden');
                        contentMain.classList.add('flex');
                    } else if (target === 'wallpaper') {
                        wallpaperSidebar.classList.remove('hidden');
                        wallpaperMain.classList.remove('hidden');
                        wallpaperMain.classList.add('flex');
                    }
                });
            });
        }

        // --- Shared Utilities ---
        const Utils = {
            File: {
                readImage(file) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => resolve(img);
                            img.onerror = reject;
                            img.src = e.target.result;
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                }
            },
            UI: {
                setupUpload(dropZone, fileInput, activeClass, callback) {
                    // Click to upload
                    dropZone.addEventListener('click', () => fileInput && fileInput.click());

                    // Drag & Drop
                    dropZone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        dropZone.classList.add(activeClass);
                    });
                    dropZone.addEventListener('dragleave', () => {
                        dropZone.classList.remove(activeClass);
                    });
                    dropZone.addEventListener('drop', async (e) => {
                        e.preventDefault();
                        dropZone.classList.remove(activeClass);

                        // 1. Files
                        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                            callback(e.dataTransfer.files);
                            return;
                        }

                        // 2. Web Images (URL)
                        const items = e.dataTransfer.items;
                        if (items) {
                            for (let i = 0; i < items.length; i++) {
                                if (items[i].type.indexOf('image') !== -1) {
                                    const file = items[i].getAsFile();
                                    if (file) {
                                        callback([file]);
                                        return;
                                    }
                                }
                            }
                        }

                        // Fallback: Try to extract URL from HTML
                        const html = e.dataTransfer.getData('text/html');
                        if (html) {
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(html, 'text/html');
                            const img = doc.querySelector('img');
                            if (img && img.src) {
                                try {
                                    Utils.Toast.show('æ­£åœ¨è·å–ç½‘ç»œå›¾ç‰‡...', true);
                                    const response = await fetch(img.src);
                                    const blob = await response.blob();
                                    const file = new File([blob], 'web-image.png', { type: blob.type });
                                    callback([file]);
                                    Utils.Toast.hide();
                                } catch (err) {
                                    console.error(err);
                                    Utils.Toast.show('æ— æ³•è·å–è¯¥å›¾ç‰‡(è·¨åŸŸé™åˆ¶)', false);
                                    setTimeout(() => Utils.Toast.hide(), 2000);
                                }
                            }
                        }
                    });

                    // Paste
                    document.addEventListener('paste', (e) => {
                        if (dropZone.offsetParent === null) return; // Only if visible

                        const items = e.clipboardData.items;
                        for (let i = 0; i < items.length; i++) {
                            if (items[i].type.indexOf('image') !== -1) {
                                const file = items[i].getAsFile();
                                callback([file]);
                                e.preventDefault();
                                break;
                            }
                        }
                    });
                },
                bindRange(rangeInput, displayElement, formatFn = (v) => v, callback) {
                    rangeInput.addEventListener('input', (e) => {
                        const val = e.target.value;
                        if (displayElement) displayElement.textContent = formatFn(val);
                        if (callback) callback(val);
                    });
                }
            },
            Toast: {
                show(msg, isLoading = true) {
                    const el = document.getElementById('statusMsg');
                    const text = document.getElementById('statusText');
                    const spinner = el.querySelector('svg');

                    el.classList.remove('hidden', 'translate-y-10', 'opacity-0');
                    text.innerText = msg;
                    if (isLoading) spinner.classList.remove('hidden');
                    else spinner.classList.add('hidden');
                },
                hide() {
                    const el = document.getElementById('statusMsg');
                    el.classList.add('translate-y-10', 'opacity-0');
                    setTimeout(() => el.classList.add('hidden'), 500);
                }
            }
        };

        // --- Puzzle Master Logic ---
        const PuzzleApp = {
            state: {
                images: [],
                ratio: 1,
                borderWidth: 1,
                borderColor: '#000000',
                quality: 0.85, // Added quality state
                isDragging: false,
                dragCell: null,
                dragX: 0,
                dragY: 0,
                currentFiles: [],
                currentLayoutId: null, // Track selected layout
                yearMaskImage: null,
                yearScale: 1, // Grid density scale
                yearScale: 1, // Grid density scale
                yearRepeat: true, // Auto-repeat images to fill grid
                yearScale: 1, // Grid density scale
                yearRepeat: true, // Auto-repeat images to fill grid
                yearMerge: false, // Randomly merge cells if image count is low
                yearText: '2025', // Custom year text
                yearGradientColors: { start: '#8b5cf6', end: '#d946ef' }, // Custom gradient colors
                yearText: '2025', // Custom year text
                yearGradientColors: { start: '#8b5cf6', end: '#d946ef' }, // Custom gradient colors
                yearMaskState: { x: 0, y: 0, scale: 1 }, // State for mask image interaction
                yearVertical: false, // Vertical stacking (2x2)
                longPressTimer: null
            },
            elements: {},

            init() {
                this.elements = {
                    dropZone: document.getElementById('puzzleDropZone'),
                    fileInput: document.getElementById('puzzleFileInput'),
                    fileList: document.getElementById('puzzleFileList'),
                    canvasContainer: document.getElementById('canvasContainer'),
                    gridContainer: document.getElementById('gridContainer'),
                    borderWidth: document.getElementById('borderWidth'),
                    borderWidthVal: document.getElementById('borderWidthVal'),
                    borderColor: document.getElementById('borderColor'),
                    borderColorText: document.getElementById('borderColorText'),
                    borderColorPreview: document.getElementById('borderColorPreview'),

                    // Export
                    puzzleQuality: document.getElementById('puzzleQuality'),
                    puzzleQualityVal: document.getElementById('puzzleQualityVal'), // Added quality value display
                    ratioBtns: document.querySelectorAll('.ratio-btn'),
                    customRatioBtn: document.getElementById('customRatioBtn'),
                    customRatioInput: document.getElementById('customRatioInput'),
                    ratioW: document.getElementById('ratioW'),
                    ratioH: document.getElementById('ratioH'),
                    downloadBtn: document.getElementById('puzzleDownloadBtn'),
                    interactionHint: document.getElementById('interactionHint'),
                    puzzleEmptyState: document.getElementById('puzzleEmptyState') // Added empty state element
                };
                this.setupEventListeners();
                this.updateCanvasSize();

                // Add ResizeObserver for responsive image placement
                if (window.ResizeObserver) {
                    let resizeTimeout;
                    const resizeObserver = new ResizeObserver(() => {
                        // Debounce resize events
                        if (resizeTimeout) clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                            this.updateCanvasSize();
                            // Re-calculate placements
                            const cells = this.elements.gridContainer.querySelectorAll('.grid-cell');
                            const isYearLayout = this.state.currentLayoutId === 'year-2025';
    
                            cells.forEach((cell, i) => {
                                const img = cell.querySelector('img');
                                if (!img) return;
                                
                                let imgData;
                                
                                if (isYearLayout) {
                                    const id = img.dataset.id;
                                    if (id) {
                                        imgData = this.state.images.find(item => String(item.id) === id);
                                    }
                                } else {
                                    imgData = this.state.images[i];
                                }
    
                                if (imgData) {
                                    this.updateImagePlacement(cell, img, imgData);
                                }
                            });
                        }, 100); // 100ms debounce
                    });
                    resizeObserver.observe(this.elements.gridContainer);
                } else {
                    window.addEventListener('resize', () => this.updateCanvasSize());
                }
            },

            setupEventListeners() {
                const els = this.elements;

                // Use Utils for Drag & Drop
                Utils.UI.setupUpload(els.dropZone, els.fileInput, 'border-violet-500', (files) => {
                    this.handleFiles(files);
                });
                els.fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));

                // Year Mask Upload
                const maskInput = document.getElementById('yearMaskInput');
                if (maskInput) {
                // Year Mask Upload
                const maskInput = document.getElementById('yearMaskInput');
                if (maskInput) {
                    maskInput.addEventListener('change', async (e) => {
                        if (e.target.files.length > 0) {
                            const file = e.target.files[0];
                            // Optimization: Use createObjectURL instead of FileReader
                            const src = URL.createObjectURL(file);
                            const img = new Image();
                            img.src = src;
                            await new Promise(r => img.onload = r);
                            
                            // Revoke old object URL if exists
                            if (this.state.yearMaskImage && this.state.yearMaskImage.src.startsWith('blob:')) {
                                URL.revokeObjectURL(this.state.yearMaskImage.src);
                            }

                            this.state.yearMaskImage = img;
                            this.renderGrid();
                        }
                    });
                }
                }
                
                // Year Settings Controls
                const scaleSel = document.getElementById('yearScaleSelect');
                if (scaleSel) scaleSel.addEventListener('change', (e) => {
                    this.state.yearScale = parseInt(e.target.value);
                    this.renderGrid();
                });
                
                const repeatCheck = document.getElementById('yearRepeatCheck');
                if (repeatCheck) repeatCheck.addEventListener('change', (e) => {
                    this.state.yearRepeat = e.target.checked;
                    this.renderGrid();
                });

                const mergeCheck = document.getElementById('yearMergeCheck');
                if (mergeCheck) mergeCheck.addEventListener('change', (e) => {
                    this.state.yearMerge = e.target.checked;
                    this.renderGrid();
                });
                
                const verticalCheck = document.getElementById('yearVerticalCheck');
                if (verticalCheck) verticalCheck.addEventListener('change', (e) => {
                    this.state.yearVertical = e.target.checked;
                    this.renderGrid();
                });

                const yearInput = document.getElementById('yearTextInput');
                if (yearInput) yearInput.addEventListener('input', (e) => {
                    const val = e.target.value.trim();
                    if (val.length === 4 && /^\d+$/.test(val)) {
                        this.state.yearText = val;
                        this.updateAvailableLayouts(); // Sync button text
                        this.renderGrid();
                    }
                });

                // Year Gradient Inputs
                const gradStart = document.getElementById('yearGradientStart');
                const gradEnd = document.getElementById('yearGradientEnd');
                
                const updateGradient = () => {
                    this.state.yearGradientColors.start = gradStart.value;
                    this.state.yearGradientColors.end = gradEnd.value;
                    this.state.yearMaskImage = null; // Clear image
                    this.renderGrid();
                };

                if (gradStart && gradEnd) {
                     gradStart.addEventListener('input', updateGradient);
                     gradEnd.addEventListener('input', updateGradient);
                }

                // Use Utils for Range Inputs
                Utils.UI.bindRange(els.borderWidth, els.borderWidthVal, (v) => `${v}px`, (v) => {
                    this.state.borderWidth = v;
                    this.renderGrid();
                });

                els.borderColor.addEventListener('input', (e) => this.updateBorderColor(e.target.value));
                els.borderColorText.addEventListener('input', (e) => {
                    els.borderColor.value = e.target.value;
                    this.updateBorderColor(e.target.value);
                });

                // Use Utils for Quality Slider
                Utils.UI.bindRange(els.puzzleQuality, els.puzzleQualityVal, (v) => `${v}%`, (v) => {
                    this.state.quality = parseInt(v) / 100;
                });

                // Ratio Button Logic with robust state handling
                const activeClasses = ['active', 'border-violet-500', 'bg-violet-50', 'dark:bg-blue-900/30', 'text-violet-600', 'dark:text-blue-400'];
                const inactiveClasses = ['border-gray-200', 'dark:border-slate-700', 'hover:bg-gray-100', 'dark:hover:bg-slate-800', 'text-gray-500'];

                const setBtnState = (btn, isActive) => {
                    if (isActive) {
                        btn.classList.add(...activeClasses);
                        btn.classList.remove(...inactiveClasses);
                    } else {
                        btn.classList.remove(...activeClasses);
                        btn.classList.add(...inactiveClasses);
                    }
                };

                els.ratioBtns.forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (btn.id === 'customRatioBtn') {
                            els.customRatioInput.classList.remove('hidden');
                            els.customRatioInput.classList.add('flex');
                        } else {
                            els.customRatioInput.classList.add('hidden');
                            els.customRatioInput.classList.remove('flex');
                            this.setRatio(btn.dataset.ratio);
                        }
                        
                        els.ratioBtns.forEach(b => setBtnState(b, false));
                        setBtnState(btn, true);
                    });
                });

                els.ratioW.addEventListener('input', () => this.updateCustomRatio());
                els.ratioH.addEventListener('input', () => this.updateCustomRatio());
                els.downloadBtn.addEventListener('click', () => this.exportImage());
            },

            updateBorderColor(color) {
                this.state.borderColor = color;
                // els.borderColorVal.textContent = color; // Removed as we use text input now
                if (this.elements.borderColorPreview) {
                    this.elements.borderColorPreview.style.backgroundColor = color;
                }
                this.elements.borderColorText.value = color;
                this.renderGrid();
            },

            setRatio(ratioStr) {
                const [w, h] = ratioStr.split(':').map(Number);
                this.state.ratio = w / h;
                this.updateCanvasSize();
            },

            updateCustomRatio() {
                const w = parseFloat(this.elements.ratioW.value) || 1;
                const h = parseFloat(this.elements.ratioH.value) || 1;
                this.state.ratio = w / h;
                this.updateCanvasSize();
            },
            
            setYearGradient(classes) {
                this.state.yearGradient = classes;
                this.state.yearMaskImage = null; // Clear image to show gradient
                this.renderGrid();
            },

            // Helper to shuffle array
            shuffle(array) {
                let currentIndex = array.length,  randomIndex;
                while (currentIndex != 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
                }
                return array;
            },

            updateCanvasSize() {
                if (!this.elements.canvasContainer) return;
                const container = this.elements.canvasContainer.parentElement;
                if (!container || container.clientWidth === 0) return; // Hidden

                const padding = window.innerWidth < 768 ? 32 : 64;
                const maxWidth = container.clientWidth - padding;
                const maxHeight = container.clientHeight - padding;

                let w, h;
                if (maxWidth / maxHeight > this.state.ratio) {
                    h = maxHeight;
                    w = h * this.state.ratio;
                } else {
                    w = maxWidth;
                    h = w / this.state.ratio;
                }

                this.elements.canvasContainer.style.width = `${w}px`;
                this.elements.canvasContainer.style.height = `${h}px`;
            },

            // Helper to generate thumbnail
            // Helper to generate thumbnail
            createThumbnail(file, maxDim = 800, quality = 0.8) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    
                    // Optimization: If maxDim is 0, use original (Blob URL)
                    if (maxDim === 0) {
                         const url = URL.createObjectURL(file);
                         const img = new Image();
                         img.onload = () => resolve({ src: url, originalW: img.naturalWidth, originalH: img.naturalHeight, isBlob: true });
                         img.onerror = () => resolve(null);
                         img.src = url;
                         return;
                    }

                    reader.onload = (e) => {
                         const img = new Image();
                         img.onload = () => {
                             const canvas = document.createElement('canvas');
                             let w = img.width;
                             let h = img.height;
                             
                             if (w > maxDim || h > maxDim) {
                                 if (w > h) {
                                     h = Math.round((h * maxDim) / w);
                                     w = maxDim;
                                 } else {
                                     w = Math.round((w * maxDim) / h);
                                     h = maxDim;
                                 }
                             }
                             
                             canvas.width = w;
                             canvas.height = h;
                             const ctx = canvas.getContext('2d');
                             ctx.drawImage(img, 0, 0, w, h);
                             
                             const thumbSrc = canvas.toDataURL('image/jpeg', quality);
                             resolve({ src: thumbSrc, originalW: img.naturalWidth, originalH: img.naturalHeight });
                         };
                         img.onerror = () => resolve(null);
                         img.src = e.target.result;
                    };
                    reader.onerror = () => resolve(null);
                    reader.readAsDataURL(file);
                });
            },

            async handleFiles(files) {
                const validFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
                if (validFiles.length === 0) return;

                if (this.state.images.length + validFiles.length > 300) {
                    alert('æœ€å¤šæ”¯æŒ300å¼ å›¾ç‰‡æ‹¼æ¥');
                    return;
                }

                const loadingBtn = document.getElementById('puzzleUploadBtn');
                const originalText = loadingBtn ? loadingBtn.innerHTML : '';
                if(loadingBtn) {
                    loadingBtn.innerHTML = '<span class="animate-pulse">0%</span>';
                    loadingBtn.disabled = true;
                }

                // Progressive Loading Strategy
                const BATCH_SIZE = 12;
                const fileArray = validFiles;
                let processedCount = 0;

                // Dynamic Quality Strategy
                const totalCount = this.state.images.length + validFiles.length;
                let thumbMaxDim = 800;
                let thumbQuality = 0.8;
                
                if (totalCount <= 6) {
                    thumbMaxDim = 0; // Original
                } else if (totalCount <= 20) {
                    thumbMaxDim = 1600;
                    thumbQuality = 0.85;
                } else if (totalCount <= 50) {
                    thumbMaxDim = 1024;
                    thumbQuality = 0.8;
                } else {
                    thumbMaxDim = 600;
                    thumbQuality = 0.7;
                }

                const processNextBatch = async (startIndex) => {
                    if (startIndex >= fileArray.length) {
                        // All done
                        if(loadingBtn) {
                            loadingBtn.innerHTML = originalText;
                            loadingBtn.disabled = false;
                        }
                        return;
                    }

                    const batch = fileArray.slice(startIndex, startIndex + BATCH_SIZE);
                    
                    try {
                        // Process current batch
                        const promises = batch.map(async file => {
                            const thumbData = await this.createThumbnail(file, thumbMaxDim, thumbQuality);
                            if (thumbData) {
                                return {
                                    id: Date.now() + Math.random(),
                                    file: file,
                                    src: thumbData.src,
                                    x: 0, y: 0, scale: 1,
                                    originalWidth: thumbData.originalW,
                                    originalHeight: thumbData.originalH
                                };
                            }
                            return null;
                        });

                        const results = await Promise.all(promises);
                        const validResults = results.filter(r => r !== null);

                        if (validResults.length > 0) {
                            this.state.images.push(...validResults);
                            // Update UI immediately for this batch
                            this.renderGrid();
                            this.updateFileList();
                            this.updateAvailableLayouts();
                        }
                        
                        processedCount += batch.length;
                        if(loadingBtn) {
                            loadingBtn.innerHTML = `<span class="animate-pulse">${Math.round(Math.min(100, (processedCount/fileArray.length)*100))}%</span>`;
                        }

                    } catch (err) {
                        console.error("Chunk load error", err);
                    }

                    // Schedule next batch to let UI breathe
                    setTimeout(() => {
                        processNextBatch(startIndex + BATCH_SIZE);
                    }, 20); 
                };

                // Start processing
                processNextBatch(0);
            },

            updateFileList() {
                this.elements.fileList.innerHTML = '';
                this.state.images.forEach((img, index) => {
                    const div = document.createElement('div');
                    div.className = 'relative aspect-square rounded-lg overflow-hidden group';
                    div.innerHTML = `
                        <img src="${img.src}" class="w-full h-full object-cover">
                        <button onclick="PuzzleApp.removeImage(${index})" class="absolute top-1 right-1 bg-red-500 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 transition-opacity">
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    `;
                    this.elements.fileList.appendChild(div);
                });
            },

            removeImage(index) {
                const img = this.state.images[index];
                if (img.src.startsWith('blob:')) {
                    URL.revokeObjectURL(img.src);
                }
                this.state.images.splice(index, 1);
                this.renderGrid();
                this.updateFileList();
                this.updateAvailableLayouts();
            },

            renderGrid() {
                const count = this.state.images.length;
                const container = this.elements.gridContainer;
                container.innerHTML = '';

                // Update button state
                if (this.elements.downloadBtn) {
                    this.elements.downloadBtn.disabled = count === 0;
                }

                if (count === 0) {
                    this.elements.puzzleEmptyState.classList.remove('hidden');
                    this.elements.canvasContainer.classList.add('hidden');
                    return;
                }

                this.elements.puzzleEmptyState.classList.add('hidden');
                this.elements.canvasContainer.classList.remove('hidden');

                const layout = this.getLayout(count);
                const isYearLayout = layout.id === 'year-2025';
                
                // For Year Layout, we use 0 gap to make the mask seamless, and simulate borders on photos
                const gap = isYearLayout ? 0 : this.state.borderWidth;

                container.style.gridTemplateColumns = `repeat(${layout.cols}, 1fr)`;
                container.style.gridTemplateRows = `repeat(${layout.rows}, 1fr)`;
                container.style.gap = `${gap}px`;
                container.style.backgroundColor = this.state.borderColor;
                container.style.padding = `${this.state.borderWidth}px`;

                // Show/Hide Year Mask UI
                const yearUI = document.getElementById('yearMaskSection');
                if (yearUI) {
                    yearUI.classList.toggle('hidden', !isYearLayout);
                }
                
                // Year Layout: Add a single background layer behind the grid
                if (isYearLayout) {
                    container.style.position = 'relative';
                    const bgLayer = document.createElement('div');
                    // Removed inset-0, calculate exact position to inside of padding
                    bgLayer.className = 'absolute'; 
                    const bw = this.state.borderWidth;
                    bgLayer.style.left = `${bw}px`;
                    bgLayer.style.top = `${bw}px`;
                    bgLayer.style.width = `calc(100% - ${bw * 2}px)`;
                    bgLayer.style.height = `calc(100% - ${bw * 2}px)`;
                    bgLayer.style.zIndex = '0'; // Behind cells
                    bgLayer.style.overflow = 'hidden'; // Clip the moving image
                    
                    if (this.state.yearMaskImage) {
                         const img = document.createElement('img');
                         img.src = this.state.yearMaskImage.src;
                         img.className = 'absolute w-full h-full object-cover origin-center cursor-move';
                         const { x, y, scale } = this.state.yearMaskState;
                         img.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
                         
                         bgLayer.appendChild(img);
                         this.setupYearMaskInteraction(img);
                    } else {
                         const { start, end } = this.state.yearGradientColors;
                         bgLayer.style.background = `linear-gradient(135deg, ${start}, ${end})`;
                    }
                    container.appendChild(bgLayer);
                }

                // If Year Layout with specific cells (Pre-calculated spans/masks)
                // Otherwise we iterate the images (legacy/standard grids)
                const isCustomGrid = isYearLayout && layout.cells;
                const iterCount = isCustomGrid ? layout.cells.length : this.state.images.length;
                let imageIndex = 0;

                const fragment = document.createDocumentFragment();

                for (let i = 0; i < iterCount; i++) {
                    const cell = document.createElement('div');
                    // z-10 ensures cells correspond to interaction layer and cover background if opaque
                    cell.className = 'grid-cell overflow-hidden relative group z-10'; 
                    
                    let isMaskCell = false;
                    
                    if (isCustomGrid) {
                        const cellDef = layout.cells[i];
                        // Apply position and size
                        cell.style.gridColumnStart = cellDef.x + 1;
                        cell.style.gridColumnEnd = `span ${cellDef.w}`;
                        cell.style.gridRowStart = cellDef.y + 1;
                        cell.style.gridRowEnd = `span ${cellDef.h}`;
                        
                        if (cellDef.type === 'mask') isMaskCell = true;
                    } else {
                        // Standard Grid Layout logic for spans
                         const row = Math.floor(i / layout.cols);
                         const col = i % layout.cols;
                    }
                    
                    // Year Layout: Simulate borders for non-mask cells
                    if (isYearLayout && !isMaskCell) {
                        const borderW = this.state.borderWidth / 2;
                        cell.style.border = `${borderW}px solid ${this.state.borderColor}`;
                        cell.style.boxSizing = 'border-box';
                        cell.style.backgroundColor = '#e5e7eb'; // Opaque gray to hide background
                    } else if (!isYearLayout) {
                         cell.style.backgroundColor = '#e5e7eb'; // Standard
                    }

                    if (isMaskCell) {
                        cell.classList.add('year-mask-cell');
                        cell.style.backgroundColor = 'transparent'; // Reveal background layer
                        cell.classList.add('year-mask-cell');
                        cell.style.backgroundColor = 'transparent'; // Reveal background layer
                        cell.style.pointerEvents = 'none'; // Allow clicks to pass through to background
                        fragment.appendChild(cell);
                        continue;
                    }
                    
                    // ... (rest of logic)

                    // Check if we have images or should repeat
                    const shouldRender = imageIndex < this.state.images.length || (this.state.yearRepeat && this.state.images.length > 0);

                    if (shouldRender) {
                        const sourceIndex = this.state.yearRepeat ? (imageIndex % this.state.images.length) : imageIndex;
                        const imgData = this.state.images[sourceIndex];
                        imageIndex++;

                        if (!isCustomGrid && layout.spans && layout.spans[i]) {
                             if (layout.spans[i].col) cell.style.gridColumn = `span ${layout.spans[i].col}`;
                             if (layout.spans[i].row) cell.style.gridRow = `span ${layout.spans[i].row}`;
                        }

                        const img = document.createElement('img');
                        img.src = imgData.src;
                        img.dataset.id = imgData.id; // Store ID for resize mapping
                        img.className = 'absolute transition-transform duration-75 ease-out origin-center';

                        cell.appendChild(img);
                        fragment.appendChild(cell);

                        requestAnimationFrame(() => {
                            this.updateImagePlacement(cell, img, imgData);
                        });

                        this.setupImageInteraction(cell, img, imgData);
                    } else if (isYearLayout) {
                        // Empty filler cell
                        fragment.appendChild(cell);
                    }
                }
                
                container.appendChild(fragment);

                if (!isYearLayout) {
                   // Legacy loop for other layouts (handled implicitly by loop above if we set iterCount correctly)
                   // Actually, standard layouts iterate `this.state.images`. 
                   // The loop above unifies it roughly, but let's be careful.
                   // Refactor: The loop above works for Grid. 
                   // But `layout.spans` logic in standard layouts relies on `index` matching `this.state.images`.
                   // Let's keep the logic clean.
                }

                this.elements.interactionHint.classList.remove('opacity-0');
                setTimeout(() => this.elements.interactionHint.classList.add('opacity-0'), 3000);
            },

            // New helper to position image like object-fit: cover but manually
            updateImagePlacement(cell, img, imgData) {
                const cellRect = cell.getBoundingClientRect();
                const cellW = cellRect.width;
                const cellH = cellRect.height;

                if (cellW === 0 || cellH === 0) return;

                const imgW = imgData.originalWidth || img.naturalWidth;
                const imgH = imgData.originalHeight || img.naturalHeight;

                if (!imgW || !imgH) return; // Image not loaded yet?

                const imgRatio = imgW / imgH;
                const cellRatio = cellW / cellH;

                let renderW, renderH;

                // Emulate object-fit: cover
                // Add +1px buffer to prevent white edges due to subpixel rounding
                const buffer = 1;

                if (cellRatio > imgRatio) {
                    // Cell is wider -> width matches cell width (plus buffer)
                    renderW = cellW + buffer;
                    renderH = renderW / imgRatio;
                } else {
                    // Cell is taller -> height matches cell height (plus buffer)
                    renderH = cellH + buffer;
                    renderW = renderH * imgRatio;
                }

                // Center the image
                const left = (cellW - renderW) / 2;
                const top = (cellH - renderH) / 2;

                img.style.width = `${renderW}px`;
                img.style.height = `${renderH}px`;
                img.style.left = `${left}px`;
                img.style.top = `${top}px`;

                // Save base dimensions for interaction
                imgData.baseW = renderW;
                imgData.baseH = renderH;
                imgData.baseLeft = left;
                imgData.baseTop = top;

                // Apply transform (user pan/zoom)
                img.style.transform = `translate(${imgData.x}px, ${imgData.y}px) scale(${imgData.scale})`;
            },

            LAYOUTS: {
                2: [
                    { id: '2-v', name: 'puzzle.layout.2_v', icon: 'M4 4h7v16H4zm9 0h7v16h-7z', cols: 2, rows: 1, spans: [] },
                    { id: '2-h', name: 'puzzle.layout.2_h', icon: 'M4 4h16v7H4zm0 9h16v7H4z', cols: 1, rows: 2, spans: [] }
                ],
                3: [
                    { id: '3-grid-l', name: 'puzzle.layout.3_grid_l', icon: 'M4 4h7v16H4zm9 0h7v7h-7zm0 9h7v7h-7z', cols: 2, rows: 2, spans: [{ col: 1, row: 2 }, { col: 1, row: 1 }, { col: 1, row: 1 }] },
                    { id: '3-grid-r', name: 'puzzle.layout.3_grid_r', icon: 'M4 4h7v7H4zm0 9h7v7H4zm9-16h7v16h-7z', cols: 2, rows: 2, spans: [{ col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 2 }] },
                    { id: '3-v', name: 'puzzle.layout.3_v', icon: 'M4 4h4.6v16H4zm5.6 0h4.8v16H9.6zm5.8 0h4.6v16h-4.6z', cols: 3, rows: 1, spans: [] },
                    { id: '3-h', name: 'puzzle.layout.3_h', icon: 'M4 4h16v4.6H4zm0 5.6h16v4.8H4zm0 5.8h16v4.6H4z', cols: 1, rows: 3, spans: [] },
                    { id: '3-hero-top', name: 'puzzle.layout.3_hero_top', icon: 'M4 4h16v10H4zm0 11h8v5H4zm9 0h7v5h-7z', cols: 2, rows: 2, spans: [{ col: 2, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }] },
                    { id: '3-hero-bottom', name: 'puzzle.layout.3_hero_bottom', icon: 'M4 4h7v5H4zm9 0h7v5h-7zm-9 6h16v10H4z', cols: 2, rows: 2, spans: [{ col: 1, row: 1 }, { col: 1, row: 1 }, { col: 2, row: 1 }] }
                ],
                4: [
                    { id: '4-grid', name: 'puzzle.layout.4_grid', icon: 'M4 4h7v7H4zm9 0h7v7h-7zm-9 9h7v7H4zm9 0h7v7h-7z', cols: 2, rows: 2, spans: [] },
                    { id: '4-v', name: 'puzzle.layout.4_v', icon: 'M4 4h3v16H4zm4 0h3v16H8zm4 0h3v16h-3zm4 0h3v16h-3z', cols: 4, rows: 1, spans: [] },
                    { id: '4-h', name: 'puzzle.layout.4_h', icon: 'M4 4h16v3H4zm0 4h16v3H4zm0 4h16v3H4zm0 4h16v3H4z', cols: 1, rows: 4, spans: [] },
                    { id: '4-hero-top', name: 'puzzle.layout.4_hero_top', icon: 'M4 4h16v8H4zm0 9h5v7H4zm6 0h4v7h-4zm5 0h5v7h-5z', cols: 3, rows: 2, spans: [{ col: 3, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }] },
                    { id: '4-hero-left', name: 'puzzle.layout.4_hero_left', icon: 'M4 4h8v16H4zm9 0h7v5h-7zm0 6h7v5h-7zm0 6h7v4h-7z', cols: 2, rows: 3, spans: [{ col: 1, row: 3 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }] }
                ],
                5: [
                    { id: '5-grid', name: 'puzzle.layout.default', icon: 'M4 4h7v7H4zm9 0h7v7h-7zm-9 9h4.6v7H4zm5.6 0h4.6v7H9.6zm5.6 0h4.8v7h-4.8z', cols: 6, rows: 2, spans: [{ col: 3, row: 1 }, { col: 3, row: 1 }, { col: 2, row: 1 }, { col: 2, row: 1 }, { col: 2, row: 1 }] },
                    { id: '5-v', name: 'puzzle.layout.5_v', icon: 'M4 4h2.4v16H4zm3.4 0h2.4v16H7.4zm3.4 0h2.4v16h-2.4zm3.4 0h2.4v16h-2.4zm3.4 0h2.4v16h-2.4z', cols: 5, rows: 1, spans: [] },
                    { id: '5-h', name: 'puzzle.layout.5_h', icon: 'M4 4h16v2.4H4zm0 3.4h16v2.4H4zm0 3.4h16v2.4H4zm0 3.4h16v2.4H4zm0 3.4h16v2.4H4z', cols: 1, rows: 5, spans: [] },
                    { id: '5-mosaic-l', name: 'puzzle.layout.5_mosaic_l', icon: 'M4 4h7v16H4zm8 0h4v8h-4zm4 0h4v8h-4zm-4 8h4v8h-4zm4 0h4v8h-4z', cols: 4, rows: 2, spans: [{ col: 2, row: 2 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }] },
                    { id: '5-hero-top', name: 'puzzle.layout.5_hero_top', icon: 'M4 4h16v8H4zm0 9h3v7H4zm4 0h3v7H8zm4 0h3v7h-3zm4 0h4v7h-4z', cols: 4, rows: 2, spans: [{ col: 4, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }] }
                ],
                6: [
                    { id: '6-grid-3x2', name: 'puzzle.layout.6_grid_3x2', icon: 'M4 4h4.6v7H4zm5.6 0h4.6v7H9.6zm5.8 0h4.6v7h-4.6zm-11.4 9h4.6v7H4zm5.6 0h4.6v7H9.6zm5.8 0h4.6v7h-4.6z', cols: 3, rows: 2, spans: [] },
                    { id: '6-grid-2x3', name: 'puzzle.layout.6_grid_2x3', icon: 'M4 4h7v4.6H4zm9 0h7v4.6h-7zm-9 5.6h7v4.6H4zm9 0h7v4.6h-7zm-9 5.8h7v4.6H4zm9 0h7v4.6h-7z', cols: 2, rows: 3, spans: [] },
                    { id: '6-v', name: 'puzzle.layout.6_v', icon: 'M4 4h2v16H4zm3 0h2v16H7zm3 0h2v16h-2zm3 0h2v16h-2zm3 0h2v16h-2zm3 0h2v16h-2z', cols: 6, rows: 1, spans: [] },
                    { id: '6-h', name: 'puzzle.layout.6_h', icon: 'M4 4h16v2H4zm0 3h16v2H4zm0 3h16v2H4zm0 3h16v2H4zm0 3h16v2H4zm0 3h16v2H4z', cols: 1, rows: 6, spans: [] },
                    { id: '6-corner', name: 'puzzle.layout.6_corner', icon: 'M4 4h10v10H4zm11 0h5v5h-5zm0 6h5v5h-5zm-11 5h5v5H4zm6 0h5v5h-5zm6 0h5v5h-5z', cols: 3, rows: 3, spans: [{ col: 2, row: 2 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }] }
                ],
                7: [
                    { id: '7-grid', name: 'puzzle.layout.default', icon: 'M4 4h3.5v7H4zm4.5 0h3.5v7H8.5zm4.5 0h3.5v7H13zm-9 9h3v7H4zm4 0h3v7H8zm4 0h3v7h-3zm4 0h3v7h-3z', cols: 12, rows: 2, spans: [{ col: 4, row: 1 }, { col: 4, row: 1 }, { col: 4, row: 1 }, { col: 3, row: 1 }, { col: 3, row: 1 }, { col: 3, row: 1 }, { col: 3, row: 1 }] },
                    { id: '7-v', name: 'puzzle.layout.7_v', icon: 'M4 4h1.7v16H4zm2.7 0h1.7v16H6.7zm2.7 0h1.7v16h-1.7zm2.7 0h1.7v16h-1.7zm2.7 0h1.7v16h-1.7zm2.7 0h1.7v16h-1.7zm2.7 0h1.7v16h-1.7z', cols: 7, rows: 1, spans: [] },
                    { id: '7-h', name: 'puzzle.layout.7_h', icon: 'M4 4h16v1.7H4zm0 2.7h16v1.7H4zm0 2.7h16v1.7H4zm0 2.7h16v1.7H4zm0 2.7h16v1.7H4zm0 2.7h16v1.7H4zm0 2.7h16v1.7H4z', cols: 1, rows: 7, spans: [] },
                    { id: '7-hero-top', name: 'puzzle.layout.7_hero_top', icon: 'M4 4h16v8H4zm0 9h5v7H4zm5.5 0h5v7h-5zm5.5 0h5v7h-5zm-11 2h5v5-5zm5 0h5 5-5zm5 0h5 5-5z', cols: 3, rows: 3, spans: [{ col: 3, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }] }
                ],
                8: [
                    { id: '8-grid-4x2', name: 'puzzle.layout.8_grid_4x2', icon: 'M4 4h3v7H4zm4 0h3v7H8zm4 0h3v7h-3zm4 0h3v7h-3zm-12 9h3v7H4zm4 0h3v7H8zm4 0h3v7h-3zm4 0h3v7h-3z', cols: 4, rows: 2, spans: [] },
                    { id: '8-grid-2x4', name: 'puzzle.layout.8_grid_2x4', icon: 'M4 4h7v3H4zm9 0h7v3h-7zm-9 4h7v3H4zm9 0h7v3h-7zm-9 4h7v3H4zm9 0h7v3h-7zm-9 4h7v3H4zm9 0h7v3h-7z', cols: 2, rows: 4, spans: [] },
                    { id: '8-v', name: 'puzzle.layout.8_v', icon: 'M4 4h1.5v16H4zm2.5 0h1.5v16H6.5zm2.5 0h1.5v16h-1.5zm2.5 0h1.5v16h-1.5zm2.5 0h1.5v16h-1.5zm2.5 0h1.5v16h-1.5zm2.5 0h1.5v16h-1.5zm2.5 0h1.5v16h-1.5z', cols: 8, rows: 1, spans: [] },
                    { id: '8-h', name: 'puzzle.layout.8_h', icon: 'M4 4h16v1.5H4zm0 2.5h16v1.5H4zm0 2.5h16v1.5H4zm0 2.5h16v1.5H4zm0 2.5h16v1.5H4zm0 2.5h16v1.5H4zm0 2.5h16v1.5H4zm0 2.5h16v1.5H4z', cols: 1, rows: 8, spans: [] },
                    { id: '8-hero-top-2', name: 'puzzle.layout.8_hero_top_2', icon: 'M4 4h8v8H4zm8 0h8v8h-8zm-8 8h2.6v8H4zm2.6 0h2.6v8h-2.6zm2.6 0h2.6v8h-2.6zm2.6 0h2.6v8h-2.6zm2.6 0h2.6v8h-2.6zm2.6 0h2.6v8h-2.6z', cols: 6, rows: 2, spans: [{ col: 3, row: 1 }, { col: 3, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 1 }] }
                ],
                9: [
                    { id: '9-grid-3x3', name: 'puzzle.layout.9_grid_3x3', icon: 'M4 4h4.6v4.6H4zm5.6 0h4.6v4.6H9.6zm5.8 0h4.6v4.6h-4.6zm-11.4 5.6h4.6v4.6H4zm5.6 0h4.6v4.6H9.6zm5.8 0h4.6v4.6h-4.6zm-11.4 5.6h4.6v4.6H4zm5.6 0h4.6v4.6H9.6zm5.8 0h4.6v4.6h-4.6z', cols: 3, rows: 3, spans: [] },
                    { id: '9-v', name: 'puzzle.layout.9_v', icon: 'M4 4h1.3v16H4zm2.3 0h1.3v16H6.3zm2.3 0h1.3v16h-1.3zm2.3 0h1.3v16h-1.3zm2.3 0h1.3v16h-1.3zm2.3 0h1.3v16h-1.3zm2.3 0h1.3v16h-1.3zm2.3 0h1.3v16h-1.3z', cols: 9, rows: 1, spans: [] },
                    { id: '9-h', name: 'puzzle.layout.9_h', icon: 'M4 4h16v1.3H4zm0 2.3h16v1.3H4zm0 2.3h16v1.3H4zm0 2.3h16v1.3H4zm0 2.3h16v1.3H4zm0 2.3h16v1.3H4zm0 2.3h16v1.3H4z', cols: 1, rows: 9, spans: [] },
                    { id: '9-center', name: 'puzzle.layout.9_center', icon: 'M4 4h4v4H4zm4 0h8v4H8zm8 0h4v4h-4zm-12 4h4v8H4zm4 0h8v8H8zm8 0h4v8h-4zm-12 8h4v4H4zm4 0h8v4H8zm8 0h4v4h-4z', cols: 4, rows: 4, spans: [{ col: 1, row: 1 }, { col: 2, row: 1 }, { col: 1, row: 1 }, { col: 1, row: 2 }, { col: 2, row: 2 }, { col: 1, row: 2 }, { col: 1, row: 1 }, { col: 2, row: 1 }, { col: 1, row: 1 }] }
                ],
                10: [
                    { id: '10-grid-5x2', name: 'puzzle.layout.10_grid_5x2', icon: 'M4 4h2.4v7H4zm3.4 0h2.4v7H7.4zm3.4 0h2.4v7h-2.4zm3.4 0h2.4v7h-2.4zm3.4 0h2.4v7h-2.4zm-13.6 9h2.4v7H4zm3.4 0h2.4v7H7.4zm3.4 0h2.4v7h-2.4zm3.4 0h2.4v7h-2.4zm3.4 0h2.4v7h-2.4z', cols: 5, rows: 2, spans: [] },
                    { id: '10-v', name: 'puzzle.layout.10_v', icon: 'M4 4h1.2v16H4zm1.2 0h1.2v16h-1.2z', cols: 10, rows: 1, spans: [] },
                    { id: '10-h', name: 'puzzle.layout.10_h', icon: 'M4 4h16v1.2H4zm0 1.2h16v1.2H4z', cols: 1, rows: 10, spans: [] }
                ],
                11: [
                    { id: '11-grid', name: 'puzzle.layout.default', icon: 'M4 4h16v16H4z', cols: 12, rows: 3, spans: [{ col: 3, row: 1 }, { col: 3, row: 1 }, { col: 3, row: 1 }, { col: 3, row: 1 }, { col: 3, row: 1 }, { col: 3, row: 1 }, { col: 3, row: 1 }, { col: 3, row: 1 }, { col: 4, row: 1 }, { col: 4, row: 1 }, { col: 4, row: 1 }] },
                    { id: '11-v', name: 'puzzle.layout.11_v', icon: 'M4 4h1v16H4z', cols: 11, rows: 1, spans: [] },
                    { id: '11-h', name: 'puzzle.layout.11_h', icon: 'M4 4h16v1H4z', cols: 1, rows: 11, spans: [] }
                ],
                12: [
                    { id: '12-grid-4x3', name: 'puzzle.layout.12_grid_4x3', icon: 'M4 4h3v4.6H4zm4 0h3v4.6H8zm4 0h3v4.6h-3zm4 0h3v4.6h-3zm-12 5.6h3v4.6H4zm4 0h3v4.6H8zm4 0h3v4.6h-3zm4 0h3v4.6h-3zm-12 5.8h3v4.6H4zm4 0h3v4.6H8zm4 0h3v4.6h-3zm4 0h3v4.6h-3z', cols: 4, rows: 3, spans: [] },
                    { id: '12-grid-3x4', name: 'puzzle.layout.12_grid_3x4', icon: 'M4 4h4.6v3H4zm5.6 0h4.6v3H9.6zm5.8 0h4.6v3h-4.6zm-11.4 4h4.6v3H4z', cols: 3, rows: 4, spans: [] },
                    { id: '12-v', name: 'puzzle.layout.12_v', icon: 'M4 4h1v16H4z', cols: 12, rows: 1, spans: [] },
                    { id: '12-h', name: 'puzzle.layout.12_h', icon: 'M4 4h16v1H4z', cols: 1, rows: 12, spans: [] }
                ],
            },

            getLayout(n) {
                // Return selected layout from state if valid
                if (this.state.currentLayoutId) {
                    if (this.state.currentLayoutId === 'dynamic-grid') {
                        return this.generateDynamicGrid(n);
                    }
                    if (this.state.currentLayoutId.startsWith('dynamic-grid-')) {
                        const parts = this.state.currentLayoutId.split('-');
                        const dims = parts[2].split('x');
                        const c = parseInt(dims[0]);
                        const r = parseInt(dims[1]);
                        return {
                            id: this.state.currentLayoutId,
                            name: `${c}x${r}`,
                            icon: 'M4 4h16v16H4z', 
                            cols: c,
                            rows: r,
                            spans: []
                        };
                    }
                    if (this.state.currentLayoutId === 'year-2025') {
                        return this.generateYear2025Layout(n);
                    }

                    if (this.LAYOUTS[n]) {
                        const layout = this.LAYOUTS[n].find(l => l.id === this.state.currentLayoutId);
                        if (layout) return layout;
                    }
                }

                // Default handling
                if (this.LAYOUTS[n]) return this.LAYOUTS[n][0];

                // Auto-fallback for N > 12
                return this.generateDynamicGrid(n);
            },

            generateDynamicGrid(n) {
                const cols = Math.ceil(Math.sqrt(n));
                const rows = Math.ceil(n / cols);
                return { 
                    id: 'dynamic-grid', 
                    name: 'è‡ªåŠ¨ç½‘æ ¼', 
                    icon: 'M4 4h16v16H4z', 
                    cols: cols, 
                    rows: rows, 
                    spans: [] 
                };
            },

            calculateOptimalGrids(n) {
                const grids = [];
                // Find factors
                for (let i = 2; i <= Math.sqrt(n); i++) {
                    if (n % i === 0) {
                        const a = i;
                        const b = n / i;
                        
                        // Add both orientations
                        grids.push({ cols: a, rows: b });
                        if (a !== b) {
                            grids.push({ cols: b, rows: a });
                        }
                    }
                }
                // Sort by ratio closeness to 1 (squareness)
                grids.sort((g1, g2) => {
                    const r1 = Math.abs(1 - g1.cols / g1.rows);
                    const r2 = Math.abs(1 - g2.cols / g2.rows);
                    return r1 - r2;
                });
                return grids;
            },

            generateYear2025Layout(n) {
                // "2025" Layout (Dynamic Year)
                // Base: 23 cols x 11 rows
                const scale = this.state.yearScale || 1;
                const isVertical = this.state.yearVertical;
                
                let baseCols, baseRows;
                let positions, yOffsets;

                if (isVertical) {
                    // Vertical Mode: 13 cols x 19 rows (2 digits top, 2 digits bottom)
                    // Digits are 4x7.
                    // X: 2, 7 (Width 13 accommodates 2 padding + 4 + 1 gap + 4 + 2 padding)
                    // Y: Row 1 at 2, Row 2 at 10 (Height 19 accommodates 2 + 7 + 1 gap + 7 + 2)
                    baseCols = 13;
                    baseRows = 19;
                    positions = [2, 7, 2, 7]; // X coordinates for 4 digits
                    yOffsets = [2, 2, 10, 10]; // Y coordinates for 4 digits
                } else {
                    // Horizontal Mode: 23 cols x 11 rows
                    baseCols = 23;
                    baseRows = 11;
                    positions = [2, 7, 12, 17];
                    yOffsets = [2, 2, 2, 2];
                }
                
                const cols = baseCols * scale;
                const rows = baseRows * scale;

                // Digit Definitions (4x7)
                const digits = {
                    '0': [[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,0,0,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]],
                    '1': [[0,0,1,0],[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0],[1,1,1,1]], // Centered 1 looks better width 4
                    '2': [[1,1,1,1],[0,0,0,1],[0,0,0,1],[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,1,1,1]],
                    '3': [[1,1,1,1],[0,0,0,1],[0,0,0,1],[1,1,1,1],[0,0,0,1],[0,0,0,1],[1,1,1,1]],
                    '4': [[1,0,0,1],[1,0,0,1],[1,0,0,1],[1,1,1,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]],
                    '5': [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,1,1,1],[0,0,0,1],[0,0,0,1],[1,1,1,1]],
                    '6': [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]],
                    '7': [[1,1,1,1],[0,0,0,1],[0,0,0,1],[0,0,1,0],[0,0,1,0],[0,1,0,0],[0,1,0,0]],
                    '8': [[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1]],
                    '9': [[1,1,1,1],[1,0,0,1],[1,0,0,1],[1,1,1,1],[0,0,0,1],[0,0,0,1],[1,1,1,1]]
                };
                
                // Build dynamic map based on yearText
                const yearStr = this.state.yearText || '2025';
                const digitMap = [];
                
                for(let i=0; i<4; i++) {
                    const char = yearStr[i] || '0';
                    if (digits[char]) {
                        digitMap.push({
                            d: char, 
                            x: positions[i], 
                            y: yOffsets[i]
                        });
                    }
                }
                
                const maskMap = {};
                const cells = []; 
                
                // 1. Build mask map
                digitMap.forEach(item => {
                    const d = digits[item.d];
                    d.forEach((rowArr, r) => {
                        rowArr.forEach((val, c) => {
                            if (val) {
                                // Apply scaling
                                const startR = (item.y + r) * scale;
                                const startC = (item.x + c) * scale;
                                for (let ry = 0; ry < scale; ry++) {
                                    for (let cx = 0; cx < scale; cx++) {
                                        const finalR = startR + ry;
                                        const finalC = startC + cx;
                                        if (!maskMap[finalR]) maskMap[finalR] = {};
                                        maskMap[finalR][finalC] = true;
                                    }
                                }
                            }
                        });
                    });
                });

                // 2. Generate cell list with merge logic
                const occupied = Array(rows).fill(0).map(() => Array(cols).fill(false));
                
                // First, mark all mask cells
                for(let r=0; r<rows; r++) {
                    for(let c=0; c<cols; c++) {
                        if (maskMap[r] && maskMap[r][c]) {
                            occupied[r][c] = true;
                            cells.push({ x: c, y: r, w: 1, h: 1, type: 'mask' });
                        }
                    }
                }

                // Identify photo slots
                const photoSlots = [];
                for(let r=0; r<rows; r++) {
                    for(let c=0; c<cols; c++) {
                        if (!occupied[r][c]) {
                            photoSlots.push({x: c, y: r});
                        }
                    }
                }

                // Merge Logic If Enabled
                // If we want random merges to reduce count, we should process slots.
                if (this.state.yearMerge) {
                    // Try to merge empty slots
                    // Naive approach: Iterate slots, if not occupied, try to merge right or down.
                    // To make it random but effective, shuffle the slots first? 
                    // No, we need contiguous. 
                    // Let's iterate grid in order, but make random decision at each step.
                    
                    for(let r=0; r<rows; r++) {
                        for(let c=0; c<cols; c++) {
                            if (occupied[r][c]) continue;
                            
                            // It's a photo slot. Decide merge.
                            const canMergeRight = (c < cols - 1) && !occupied[r][c+1];
                            const canMergeDown = (r < rows - 1) && !occupied[r+1][c];
                            
                            let merged = false;
                            
                            // 30% chance to try merge if possible?
                            if (Math.random() > 0.5) {
                                const dir = Math.random() > 0.5 ? 'right' : 'down';
                                
                                if (dir === 'right' && canMergeRight) {
                                    occupied[r][c] = true;
                                    occupied[r][c+1] = true;
                                    cells.push({ x: c, y: r, w: 2, h: 1, type: 'photo' });
                                    merged = true;
                                } else if (dir === 'down' && canMergeDown) {
                                    occupied[r][c] = true;
                                    occupied[r+1][c] = true;
                                    cells.push({ x: c, y: r, w: 1, h: 2, type: 'photo' });
                                    merged = true;
                                }
                                
                                // Try 2x2?
                                // if (dir === '2x2' && canMergeRight && canMergeDown && !occupied[r+1][c+1]) ...
                            }
                            
                            if (!merged) {
                                occupied[r][c] = true;
                                cells.push({ x: c, y: r, w: 1, h: 1, type: 'photo' });
                            }
                        }
                    }
                } else {
                    // No merge, just fill holes
                    photoSlots.forEach(slot => {
                        cells.push({ x: slot.x, y: slot.y, w: 1, h: 1, type: 'photo' });
                    });
                }
                
                // Sort cells by Y then X to ensure DOM order is roughly efficient (optional for grid but good for debug)
                cells.sort((a,b) => (a.y - b.y) || (a.x - b.x));

                return {
                    id: 'year-2025',
                    name: 'å¹´ä»½è’™ç‰ˆ',
                    icon: 'M4 4h16v16H4zm2 2v2h2V6zm4 0v2h2V6zm4 0v2h2V6zm-8 4v2h2v-2zm4 0v2h2v-2zm4 0v2h2v-2zm-8 4v2h2v-2zm4 0v2h2v-2zm4 0v2h2v-2z', // Calendar-like icon
                    cols: cols,
                    rows: rows,
                    cells: cells, // Return full cell list
                    spans: []
                };
            },

            updateAvailableLayouts() {
                const count = this.state.images.length;
                const els = this.elements;
                const section = document.getElementById('puzzleLayoutSection');
                const container = document.getElementById('layoutSelector');

                if (!section || !container) return; // Safety

                // Determine if we should show dynamic options
                const layouts = this.LAYOUTS[count] || [];
                const extraLayouts = [];

                if (count > 12) {
                     // Always add the default "Auto" (Square-ish) first
                     extraLayouts.push(this.generateDynamicGrid(count));
                     
                     // Add specific factor grids
                     const smartGrids = this.calculateOptimalGrids(count);
                     smartGrids.forEach(g => {
                         extraLayouts.push({
                             id: `dynamic-grid-${g.cols}x${g.rows}`,
                             name: `${g.cols}x${g.rows}`,
                             icon: 'M4 4h16v16H4z', // Generic icon
                             cols: g.cols,
                             rows: g.rows,
                             spans: []
                         });
                     });
                }
                
                // Show "2025" layout if we have enough images (e.g. > 10)
                if (count >= 10) {
                    extraLayouts.push(this.generateYear2025Layout(count));
                }

                if (layouts.length <= 1 && extraLayouts.length === 0) {
                    section.classList.add('hidden');
                    return;
                }

                section.classList.remove('hidden');
                container.innerHTML = '';

                const allLayouts = [...layouts, ...extraLayouts];

                allLayouts.forEach(layout => {
                    const btn = document.createElement('button');
                    const isActive = (this.state.currentLayoutId === layout.id) || (!this.state.currentLayoutId && allLayouts[0].id === layout.id);

                    // Allow auto-selection if current is invalid
                    if (isActive && this.state.currentLayoutId !== layout.id) {
                        this.state.currentLayoutId = layout.id;
                    }

                    btn.className = `p-2 rounded-lg border flex flex-col items-center gap-1 transition-all ${isActive
                        ? 'border-violet-500 bg-violet-50 dark:bg-violet-900/20 text-violet-600 dark:text-violet-400 ring-1 ring-violet-500'
                        : 'border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-800 text-gray-500'
                        }`;
                    const displayName = (appTranslations[currentLang] && appTranslations[currentLang][layout.name]) || layout.name;
                    btn.title = displayName;
                    btn.innerHTML = `
                        <svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor">
                            <path d="${layout.icon}" />
                        </svg>
                        <span class="text-[10px] whitespace-nowrap">${displayName}</span>
                    `;

                    btn.onclick = () => {
                        this.state.currentLayoutId = layout.id;
                        this.updateAvailableLayouts(); // Re-render buttons state
                        this.renderGrid();
                    };

                    container.appendChild(btn);
                });
            },

            // Note: Ensure `this.state` has `isDragging`, `dragCell`, `dragX`, `dragY`, `longPressTimer` initialized.
            setupImageInteraction(cell, img, imgData) {
                let isPanning = false;
                let startX, startY;
                let initialX, initialY;
                let lastTap = 0;

                const handleMove = (e) => {
                    const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;

                    if (this.state.isDragging) {
                        e.preventDefault();
                        this.state.dragX = clientX;
                        this.state.dragY = clientY;
                        this.updateGhostImage(clientX, clientY);
                        return;
                    }

                    if (!isPanning) return;

                    // If moved significantly, cancel long press
                    if (Math.abs(clientX - startX) > 10 || Math.abs(clientY - startY) > 10) {
                        clearTimeout(this.state.longPressTimer);
                    }

                    if (e.cancelable) e.preventDefault(); // Prevent scroll while panning

                    const dx = clientX - startX;
                    const dy = clientY - startY;

                    // Simple translation accumulation
                    imgData.x = initialX + dx / imgData.scale; // Divide by scale to span consistent UI distance? No, translate is local.
                    // Wait, css transform translate is applied BEFORE scale or AFTER?
                    // Standard order: transform: translate() scale() -> translate happens first in local coords? 
                    // No, transform processing order:
                    // matrix = ... * translate * scale
                    // If string is "translate(x, y) scale(s)", translate applies first, then scale.
                    // So if I move 10px on screen, and scale is 2, I need to translate 5px?
                    // Actually, let's keep it simple: "translate(tx, ty) scale(s)"
                    // Visual position = origin + tx + ...
                    // If we want direct mouse mapping:
                    // It's easier if we treat x/y as screen pixels offset.
                    // But scaling happens around center (origin-center).

                    imgData.x = initialX + dx;
                    imgData.y = initialY + dy;

                    img.style.transform = `translate(${imgData.x}px, ${imgData.y}px) scale(${imgData.scale})`;
                };

                const handleEnd = (e) => {
                    clearTimeout(this.state.longPressTimer);

                    // Remove global listeners
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleEnd);
                    window.removeEventListener('touchmove', handleMove);
                    window.removeEventListener('touchend', handleEnd);

                    if (this.state.isDragging) {
                        const clientX = e.type.startsWith('touch') ? e.changedTouches[0].clientX : e.clientX;
                        const clientY = e.type.startsWith('touch') ? e.changedTouches[0].clientY : e.clientY;

                        this.handleDrop(clientX, clientY);
                        this.state.isDragging = false;
                        this.state.dragCell = null;
                        this.removeGhostImage();
                        cell.style.opacity = '1';
                        return;
                    }

                    isPanning = false;

                    // Double tap reset
                    const now = Date.now();
                    if (now - lastTap < 300) {
                        imgData.x = 0;
                        imgData.y = 0;
                        imgData.scale = 1;
                        img.style.transform = `translate(0px, 0px) scale(1)`;
                    }
                    lastTap = now;
                };

                const handleStart = (clientX, clientY) => {
                    // Long press detection for drag swap
                    this.state.longPressTimer = setTimeout(() => {
                        this.state.isDragging = true;
                        this.state.dragCell = { cell, img, imgData };
                        this.state.dragX = clientX;
                        this.state.dragY = clientY;

                        if (navigator.vibrate) navigator.vibrate(50);
                        this.createGhostImage(img, clientX, clientY);
                        cell.style.opacity = '0.5';
                    }, 500);

                    isPanning = true;
                    startX = clientX;
                    startY = clientY;
                    initialX = imgData.x;
                    initialY = imgData.y;

                    // Attach global listeners
                    window.addEventListener('mousemove', handleMove);
                    window.addEventListener('mouseup', handleEnd);
                    window.addEventListener('touchmove', handleMove, { passive: false });
                    window.addEventListener('touchend', handleEnd);
                };

                // Mouse Events
                cell.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    handleStart(e.clientX, e.clientY);
                });

                // Touch Events
                cell.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        e.preventDefault();
                        handleStart(e.touches[0].clientX, e.touches[0].clientY);
                    }
                }, { passive: false });

                // Wheel Zoom
                cell.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    // Zoom towards mouse? A bit complex for now, keep center zoom
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    const newScale = imgData.scale * delta;
                    imgData.scale = Math.max(0.1, Math.min(10, newScale));
                    img.style.transform = `translate(${imgData.x}px, ${imgData.y}px) scale(${imgData.scale})`;
                }, { passive: false });

                // Double click to reset
                cell.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    imgData.x = 0;
                    imgData.y = 0;
                    imgData.scale = 1;
                    requestAnimationFrame(() => {
                        img.style.transform = `translate(0px, 0px) scale(1)`;
                    });
                });
            },

            setupYearMaskInteraction(img) {
                let isPanning = false;
                let startX, startY;
                let initialX, initialY;

                const handleMove = (e) => {
                    if (!isPanning) return;
                    e.preventDefault();
                    
                    const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
                    
                    const dx = clientX - startX;
                    const dy = clientY - startY;
                    
                    this.state.yearMaskState.x = initialX + dx;
                    this.state.yearMaskState.y = initialY + dy;
                    
                    const { x, y, scale } = this.state.yearMaskState;
                    img.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
                };

                const handleEnd = () => {
                    isPanning = false;
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleEnd);
                    window.removeEventListener('touchmove', handleMove);
                    window.removeEventListener('touchend', handleEnd);
                };

                const startInteraction = (e) => {
                    // Prevent interaction if dragging a cell on top (though pointer-events: none handles most)
                    if (this.state.isDragging) return;

                    isPanning = true;
                    startX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
                    startY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
                    initialX = this.state.yearMaskState.x;
                    initialY = this.state.yearMaskState.y;

                    window.addEventListener('mousemove', handleMove);
                    window.addEventListener('mouseup', handleEnd);
                    window.addEventListener('touchmove', handleMove, { passive: false });
                    window.addEventListener('touchend', handleEnd);
                };

                img.addEventListener('mousedown', startInteraction);
                img.addEventListener('touchstart', startInteraction, { passive: false });
                
                // Wheel Zoom
                img.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    let newScale = this.state.yearMaskState.scale * delta;
                    newScale = Math.max(0.1, Math.min(newScale, 5)); // Limit scale
                    this.state.yearMaskState.scale = newScale;
                    
                    const { x, y, scale } = this.state.yearMaskState;
                    img.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
                }, { passive: false });
            },

            createGhostImage(sourceImg, x, y) {
                const ghost = sourceImg.cloneNode(true);
                // Reset transform for ghost
                ghost.style.transform = '';
                ghost.style.width = sourceImg.style.width; // Keep calculated size
                ghost.style.height = sourceImg.style.height;

                ghost.id = 'drag-ghost';
                ghost.style.position = 'fixed';
                // Center ghost on pointer using its dimensions? 
                // Or use parent dimensions? 
                // Let's use parent dimensions for the ghost "card" look

                const w = parseFloat(sourceImg.style.width) || sourceImg.parentElement.offsetWidth;
                const h = parseFloat(sourceImg.style.height) || sourceImg.parentElement.offsetHeight;
                // Wait, if image is huge (zoomed in), ghost shouldn't be huge?
                // Let's make ghost the size of the CELL, with the image inside it?
                // Or just the image?

                // Existing ghost logic used parentElement size. Let's stick to that for the "tile" feel.
                ghost.style.width = `${sourceImg.parentElement.offsetWidth}px`;
                ghost.style.height = `${sourceImg.parentElement.offsetHeight}px`;
                ghost.style.objectFit = 'cover'; // For ghost we can validly use object-fit if we reset src?
                // No, sourceImg is an absolute positioned img with specific size.
                // Better to clone the CELL maybe?
                // Let's stick to what we had but ensure it looks okay.
                // If I clone the img which is absolute and large, it will be messy.

                // Simpler: Create a clean ghost image
                ghost.className = 'fixed z-50 rounded-lg shadow-2xl opacity-80 pointer-events-none bg-white overflow-hidden';
                ghost.style.width = `${sourceImg.parentElement.offsetWidth}px`;
                ghost.style.height = `${sourceImg.parentElement.offsetHeight}px`;
                ghost.style.objectFit = 'cover'; // Force cover for ghost
                ghost.style.left = `${x - sourceImg.parentElement.offsetWidth / 2}px`;
                ghost.style.top = `${y - sourceImg.parentElement.offsetHeight / 2}px`;

                document.body.appendChild(ghost);
            },

            updateGhostImage(x, y) {
                const ghost = document.getElementById('drag-ghost');
                if (ghost) {
                    ghost.style.left = `${x - ghost.offsetWidth / 2}px`;
                    ghost.style.top = `${y - ghost.offsetHeight / 2}px`;
                }
            },

            removeGhostImage() {
                const ghost = document.getElementById('drag-ghost');
                if (ghost) ghost.remove();
            },

            handleDrop(x, y) {
                const cells = Array.from(this.elements.gridContainer.children);
                const targetCell = cells.find(cell => {
                    const rect = cell.getBoundingClientRect();
                    return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
                });

                if (targetCell && targetCell !== this.state.dragCell.cell) {
                    const srcIndex = this.state.images.indexOf(this.state.dragCell.imgData);
                    const targetIndex = cells.indexOf(targetCell);

                    if (srcIndex > -1 && targetIndex > -1) {
                        const temp = this.state.images[srcIndex];
                        this.state.images[srcIndex] = this.state.images[targetIndex];
                        this.state.images[targetIndex] = temp;

                        this.state.images[srcIndex].x = 0; this.state.images[srcIndex].y = 0; this.state.images[srcIndex].scale = 1;
                        this.state.images[targetIndex].x = 0; this.state.images[targetIndex].y = 0; this.state.images[targetIndex].scale = 1;

                        this.renderGrid();
                    }
                }
            },

            async exportImage() {
                if (this.state.images.length === 0) return;
                const btn = this.elements.downloadBtn;
                const originalText = btn.innerHTML;
                btn.innerHTML = '<span>ç”Ÿæˆä¸­...</span>';
                btn.disabled = true;

                try {
                    // Optimization: Increase to 4096px for Pro quality
                    const targetWidth = 4096;
                    const targetHeight = targetWidth / this.state.ratio;

                    const domRect = this.elements.gridContainer.getBoundingClientRect();
                    const scale = targetWidth / domRect.width;

                    const canvas = document.createElement('canvas');
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    const ctx = canvas.getContext('2d');

                    // Background
                    ctx.fillStyle = this.state.borderColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Year Mask Background Logic
                    if (this.state.currentLayoutId === 'year-2025') {
                         const bw = this.state.borderWidth * scale; // Border width scaled
                         
                         // Calculate inner area (same logical area as the CSS absolute div)
                         const bgX = bw;
                         const bgY = bw;
                         const bgW = canvas.width - (bw * 2);
                         const bgH = canvas.height - (bw * 2);
                         
                         ctx.save();
                         // Clip to inner area
                         ctx.beginPath();
                         ctx.rect(bgX, bgY, bgW, bgH);
                         ctx.clip();
                         
                         if (this.state.yearMaskImage) {
                             const img = new Image();
                             img.src = this.state.yearMaskImage.src;
                             await new Promise(r => img.onload = r);
                             
                             const { x, y, scale: imgScale } = this.state.yearMaskState;
                             
                             // Calculate proper placement (object-fit: cover simulation)
                             // The CSS uses: transform: translate(x, y) scale(scale) on an absolute img
                             // The img is w-full h-full (so matches bgW, bgH).
                             
                             // 1. Calculate base rendered size (cover)
                             const imgRatio = img.naturalWidth / img.naturalHeight;
                             const areaRatio = bgW / bgH;
                             
                             let renderW, renderH;
                             if (areaRatio > imgRatio) {
                                 renderW = bgW;
                                 renderH = renderW / imgRatio;
                             } else {
                                 renderH = bgH;
                                 renderW = renderH * imgRatio;
                             }
                             
                             // Center it
                             const left = bgX + (bgW - renderW) / 2;
                             const top = bgY + (bgH - renderH) / 2;
                             
                             // 2. Apply transforms
                             ctx.translate(left + renderW/2, top + renderH/2); // Move to center of image
                             ctx.translate(x * scale, y * scale); // Apply user translation (scaled)
                             ctx.scale(imgScale, imgScale); // Apply user scale
                             
                             ctx.drawImage(img, -renderW/2, -renderH/2, renderW, renderH);
                             
                         } else {
                             // Gradient
                             const { start, end } = this.state.yearGradientColors;
                             const gradient = ctx.createLinearGradient(bgX, bgY, bgX + bgW, bgY + bgH);
                             gradient.addColorStop(0, start);
                             gradient.addColorStop(1, end);
                             
                             ctx.fillStyle = gradient;
                             ctx.fillRect(bgX, bgY, bgW, bgH);
                         }
                         ctx.restore();
                    }

                    const cells = Array.from(this.elements.gridContainer.children);

                    for (let i = 0; i < cells.length; i++) {
                        const cell = cells[i];
                        const imgEl = cell.querySelector('img');
                        if (!imgEl) continue;

                        // Fix: Use ID to find image data instead of index, as grid cells != image list index in complex layouts
                        const id = imgEl.dataset.id;
                        const imgData = this.state.images.find(item => String(item.id) === id);
                        if (!imgData) continue;

                        const cellRect = cell.getBoundingClientRect();
                        const x = (cellRect.left - domRect.left) * scale;
                        const y = (cellRect.top - domRect.top) * scale;
                        const w = cellRect.width * scale;
                        const h = cellRect.height * scale;

                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(x, y, w, h);
                        ctx.clip();

                        // Load image for draw
                        const img = new Image();
                        // Use original high-res file if available, otherwise fallback to src (thumbnail or blob)
                        let exportSrc = imgData.src;
                        let isBlob = false;
                        
                        if (imgData.file) {
                             exportSrc = URL.createObjectURL(imgData.file);
                             isBlob = true;
                        }
                        
                        img.src = exportSrc;
                        await new Promise(r => img.onload = r);

                        // ... transformations ...
                        // (existing transform logic)

                        const centerX = x + w / 2;
                        const centerY = y + h / 2;

                        ctx.translate(centerX, centerY);
                        ctx.translate(imgData.x * scale, imgData.y * scale);
                        ctx.scale(imgData.scale, imgData.scale);

                        // Draw image centered
                        const imgRatio = img.naturalWidth / img.naturalHeight; 
                        const cellRatio = w / h;

                        let renderW, renderH;
                        if (cellRatio > imgRatio) {
                            renderW = w;
                            renderH = w / imgRatio;
                        } else {
                            renderH = h;
                            renderW = h * imgRatio;
                        }

                        ctx.drawImage(img, -renderW / 2, -renderH / 2, renderW, renderH);

                        ctx.restore();
                        
                        // Cleanup blob
                        if (isBlob) {
                            URL.revokeObjectURL(exportSrc);
                        }
                    }

                    // Optimization: JPEG dynamic quality
                    const dataUrl = canvas.toDataURL('image/jpeg', this.state.quality); // Used this.state.quality
                    const link = document.createElement('a');
                    link.download = `PuzzlePro_${Date.now()}.jpg`;
                    link.href = dataUrl;
                    link.click();

                } catch (err) {
                    console.error(err);
                    alert('ç”Ÿæˆå¤±è´¥ï¼Œè¯·é‡è¯•');
                } finally {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                }
            }
        };

        // --- Frame Master Logic ---
        const FrameApp = {
            currentFiles: [],
            generatedImagesData: [],
            settings: { // Moved settings here
                padding: 120,
                blur: 20,
                fontScale: 1.0,
                showExif: true,
                quality: 0.85,
                borderType: 'blur', // 'blur' or 'solid'
                borderColor: '#000000'
            },
            elements: {},

            init() {
                this.elements = {
                    dropZone: document.getElementById('frameDropZone'),
                    fileInput: document.getElementById('frameFileInput'),
                    fileCount: document.getElementById('frameFileCount'),
                    fileList: document.getElementById('frameFileList'),
                    gallery: document.getElementById('frameGallery'),
                    emptyState: document.getElementById('frameEmptyState'),
                    borderRange: document.getElementById('frameBorderRange'),
                    borderVal: document.getElementById('frameBorderVal'),
                    blurRange: document.getElementById('frameBlurRange'),
                    blurVal: document.getElementById('frameBlurVal'),
                    fontRange: document.getElementById('frameFontRange'),
                    fontVal: document.getElementById('frameFontVal'),
                    exifToggle: document.getElementById('frameExifToggle'),
                    generateBtn: document.getElementById('frameGenerateBtn'),
                    downloadAllBtn: document.getElementById('frameDownloadAllBtn'),
                    statusMsg: document.getElementById('statusMsg'),
                    statusText: document.getElementById('statusText'),
                    spinner: document.getElementById('statusMsg').querySelector('svg'),
                    qualityInput: document.getElementById('frameQuality'),
                    qualityVal: document.getElementById('frameQualityVal'),
                    borderTypeBlur: document.getElementById('frameBorderTypeBlur'),
                    borderTypeSolid: document.getElementById('frameBorderTypeSolid'),
                    borderTypeGradient: document.getElementById('frameBorderTypeGradient'),
                    borderTypeMatte: document.getElementById('frameBorderTypeMatte'),
                    borderColorInput: document.getElementById('frameBorderColor'),
                    borderColorPreview: document.getElementById('frameBorderColorPreview'),
                    borderColorText: document.getElementById('frameBorderColorText'),
                    solidColorSection: document.getElementById('frameSolidColorSection'),
                    blurSection: document.getElementById('frameBlurSection')
                };
                this.setupEventListeners();
            },

            setupEventListeners() {
                const els = this.elements;

                // Use Utils for Drag & Drop
                Utils.UI.setupUpload(els.dropZone, els.fileInput, 'border-violet-500', (files) => {
                    this.handleFiles(files);
                });
                els.fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));

                // Use Utils for Range Inputs
                Utils.UI.bindRange(els.borderRange, els.borderVal);
                Utils.UI.bindRange(els.blurRange, els.blurVal);
                Utils.UI.bindRange(els.fontRange, els.fontVal, (v) => v + 'x');

                Utils.UI.bindRange(els.qualityInput, els.qualityVal, (v) => `${v}%`, (v) => {
                    this.settings.quality = parseInt(v) / 100;
                });

                els.generateBtn.addEventListener('click', () => this.processFiles());
                els.downloadAllBtn.addEventListener('click', () => this.downloadAll());

                // Border type switching
                els.borderTypeBlur.addEventListener('click', () => this.switchBorderType('blur'));
                els.borderTypeSolid.addEventListener('click', () => this.switchBorderType('solid'));
                els.borderTypeGradient.addEventListener('click', () => this.switchBorderType('gradient'));
                els.borderTypeMatte.addEventListener('click', () => this.switchBorderType('matte'));

                // Color picker
                els.borderColorInput.addEventListener('input', (e) => {
                    const color = e.target.value;
                    this.settings.borderColor = color;
                    els.borderColorText.value = color.toUpperCase();
                    els.borderColorPreview.style.backgroundColor = color;
                });

                // Color text input
                els.borderColorText.addEventListener('input', (e) => {
                    let color = e.target.value;
                    if (color.match(/^#[0-9A-Fa-f]{6}$/)) {
                        this.settings.borderColor = color;
                        els.borderColorInput.value = color;
                        els.borderColorPreview.style.backgroundColor = color;
                    }
                });
                els.borderColorText.addEventListener('change', (e) => {
                    let color = e.target.value;
                    if (!color.startsWith('#')) color = '#' + color;
                    if (color.match(/^#[0-9A-Fa-f]{6}$/)) {
                        this.settings.borderColor = color;
                        els.borderColorInput.value = color;
                        els.borderColorPreview.style.backgroundColor = color;
                        e.target.value = color.toUpperCase();
                    } else {
                        // Revert to valid color
                        e.target.value = this.settings.borderColor.toUpperCase();
                    }
                });
            },

            switchBorderType(type) {
                this.settings.borderType = type;
                const els = this.elements;
                const types = ['Blur', 'Solid', 'Gradient', 'Matte'];

                // Update button states
                types.forEach(t => {
                    const btn = els[`borderType${t}`];
                    const isActive = t.toLowerCase() === type;
                    if (isActive) {
                        btn.classList.add('active', 'border-violet-500', 'bg-violet-50', 'dark:bg-blue-900/20', 'text-violet-600', 'dark:text-blue-400');
                        btn.classList.remove('border-gray-200', 'dark:border-slate-700', 'hover:border-gray-300', 'dark:hover:border-gray-500', 'text-gray-600', 'dark:text-slate-400');
                    } else {
                        btn.classList.remove('active', 'border-violet-500', 'bg-violet-50', 'dark:bg-blue-900/20', 'text-violet-600', 'dark:text-blue-400');
                        btn.classList.add('border-gray-200', 'dark:border-slate-700', 'hover:border-gray-300', 'dark:hover:border-gray-500', 'text-gray-600', 'dark:text-slate-400');
                    }
                });

                // Update controls visibility
                els.blurSection.classList.add('hidden');
                els.solidColorSection.classList.add('hidden');

                if (type === 'blur') {
                    els.blurSection.classList.remove('hidden');
                } else if (type === 'solid' || type === 'matte') {
                    els.solidColorSection.classList.remove('hidden');
                }
                // Gradient has no extra controls for now
            },

            handleFiles(files) {
                this.currentFiles = Array.from(files);
                const els = this.elements;

                // Update button state
                if (els.generateBtn) {
                    els.generateBtn.disabled = this.currentFiles.length === 0;
                }

                if (this.currentFiles.length > 0) {
                    els.fileCount.innerText = `${this.currentFiles.length} å¼ `;
                    els.fileCount.classList.remove('hidden');
                } else {
                    els.fileCount.classList.add('hidden');
                }

                this.updateFileList();
            },

            updateFileList() {
                this.elements.fileList.innerHTML = '';
                this.currentFiles.forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const div = document.createElement('div');
                        div.className = 'relative aspect-square rounded-lg overflow-hidden group';
                        div.innerHTML = `
                            <img src="${e.target.result}" class="w-full h-full object-cover">
                            <button onclick="FrameApp.removeFile(${index})" class="absolute top-1 right-1 bg-red-500 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                            </button>
                        `;
                        this.elements.fileList.appendChild(div);
                    };
                    reader.readAsDataURL(file);
                });
            },

            removeFile(index) {
                this.currentFiles.splice(index, 1);
                this.handleFiles(this.currentFiles);
            },

            showToast(msg, isLoading = true) {
                Utils.Toast.show(msg, isLoading);
            },

            hideToast() {
                Utils.Toast.hide();
            },

            async processFiles() {
                if (this.currentFiles.length === 0) { alert("è¯·å…ˆä¸Šä¼ ç…§ç‰‡"); return; }

                const els = this.elements;
                els.gallery.innerHTML = '';
                els.emptyState.classList.add('hidden');
                this.generatedImagesData = [];
                els.downloadAllBtn.disabled = true;

                this.showToast(`å‡†å¤‡å¤„ç†...`);

                const settings = {
                    padding: parseInt(els.borderRange.value),
                    blur: parseInt(els.blurRange.value),
                    fontScale: parseFloat(els.fontRange.value),
                    showExif: els.exifToggle.checked,
                    quality: this.settings.quality,
                    borderType: this.settings.borderType,
                    borderColor: this.settings.borderColor
                };

                for (let i = 0; i < this.currentFiles.length; i++) {
                    els.statusText.innerText = `æ­£åœ¨å¤„ç† ${i + 1}/${this.currentFiles.length} ...`;
                    await this.processSingleImage(this.currentFiles[i], settings);
                }

                this.showToast("å…¨éƒ¨å®Œæˆ", false);
                setTimeout(() => this.hideToast(), 2000);

                if (this.generatedImagesData.length > 0) {
                    els.downloadAllBtn.disabled = false;
                }
            },

            processSingleImage(file, settings) {
                return new Promise((resolve) => {
                    Utils.File.readImage(file).then(img => {
                        EXIF.getData(img, () => {
                            const make = EXIF.getTag(img, "Make");
                            const model = EXIF.getTag(img, "Model");
                            const fNumber = EXIF.getTag(img, "FNumber");
                            const focalLen = EXIF.getTag(img, "FocalLength");
                            const iso = EXIF.getTag(img, "ISOSpeedRatings");
                            const exposure = EXIF.getTag(img, "ExposureTime");

                            const exifData = {
                                hasData: !!(make || model),
                                camera: [make, model].filter(Boolean).join(" ").replace("undefined", "").trim(),
                                iso: iso,
                                fstop: fNumber ? `f/${this.formatNumber(fNumber)}` : null,
                                shutter: this.formatShutter(exposure),
                                focal: focalLen ? `${this.formatNumber(focalLen)}mm` : null
                            };
                            this.createCanvasFrame(img, exifData, settings, file.name, resolve);
                        });
                    });
                });
            },

            formatNumber(num) {
                if (!num && num !== 0) return null;
                const val = parseFloat(num);
                if (isNaN(val)) return null;
                return parseFloat(val.toFixed(2)).toString();
            },

            formatShutter(exposureTime) {
                if (!exposureTime) return null;
                if (exposureTime >= 1) return this.formatNumber(exposureTime) + "s";
                return "1/" + Math.round(1 / exposureTime) + "s";
            },

            createCanvasFrame(img, exif, settings, filename, resolveCallback) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // Optimization: Limit max dimension to 4096px
                const MAX_DIMENSION = 4096;
                let width = img.width;
                let height = img.height;

                if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
                    const ratio = width / height;
                    if (width > height) {
                        width = MAX_DIMENSION;
                        height = width / ratio;
                    } else {
                        height = MAX_DIMENSION;
                        width = height * ratio;
                    }
                }

                // Scale factor for UI elements (border, text) relative to the new size
                // We use a reference of 2000px for consistent sizing logic
                const scaleFactor = Math.max(width, height) / 2000;
                const realPadding = settings.padding * scaleFactor;
                const canvasWidth = width + (realPadding * 2);
                const canvasHeight = height + (realPadding * 2);

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                // Background - check border type
                if (settings.borderType === 'solid' || settings.borderType === 'matte') {
                    // Solid color background
                    ctx.fillStyle = settings.borderColor;
                    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                } else if (settings.borderType === 'gradient') {
                    // Gradient background
                    try {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = 2;
                        tempCanvas.height = 2;
                        const tCtx = tempCanvas.getContext('2d');
                        tCtx.drawImage(img, 0, 0, 2, 2);
                        const data = tCtx.getImageData(0, 0, 2, 2).data;
                        // TL: 0-3, TR: 4-7, BL: 8-11, BR: 12-15

                        const gradient = ctx.createLinearGradient(0, 0, canvasWidth, canvasHeight);
                        gradient.addColorStop(0, `rgb(${data[0]},${data[1]},${data[2]})`);
                        gradient.addColorStop(1, `rgb(${data[12]},${data[13]},${data[14]})`);

                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                    } catch (e) {
                        console.error("Gradient generation failed", e);
                        ctx.fillStyle = "#333";
                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                    }
                } else {
                    // Blurred background (original behavior)
                    ctx.fillStyle = "#0F172A";
                    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                    // Draw background image for blur
                    ctx.save();
                    // Draw slightly larger to cover edges
                    ctx.drawImage(img, -canvasWidth * 0.05, -canvasHeight * 0.05, canvasWidth * 1.1, canvasHeight * 1.1);

                    // Apply Blur (StackBlur)
                    if (settings.blur > 0) {
                        try {
                            // Use a fixed small size for blur canvas for performance
                            const blurCanvas = document.createElement('canvas');
                            const blurCtx = blurCanvas.getContext('2d');

                            // Limit blur source to max 360px for speed
                            const blurMaxDim = 360;
                            let bw = canvasWidth;
                            let bh = canvasHeight;
                            const bRatio = bw / bh;
                            if (bw > blurMaxDim || bh > blurMaxDim) {
                                if (bw > bh) { bw = blurMaxDim; bh = bw / bRatio; }
                                else { bh = blurMaxDim; bw = bh * bRatio; }
                            }

                            blurCanvas.width = bw;
                            blurCanvas.height = bh;

                            blurCtx.drawImage(img, -bw * 0.05, -bh * 0.05, bw * 1.1, bh * 1.1);

                            // Apply StackBlur to the small canvas
                            const radius = Math.round(settings.blur * 0.5);

                            if (radius > 0) {
                                this.stackBlurCanvasRGB(blurCanvas, 0, 0, blurCanvas.width, blurCanvas.height, radius);
                            }

                            // Clear the background and draw blurred image
                            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                            ctx.fillStyle = "#0F172A";
                            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                            ctx.drawImage(blurCanvas, 0, 0, blurCanvas.width, blurCanvas.height, 0, 0, canvasWidth, canvasHeight);

                            // Apply brightness darken
                            ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
                            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                        } catch (e) {
                            console.error('Blur failed:', e);
                        }
                    }

                    ctx.restore();
                }


                // Shadow
                ctx.save();
                ctx.shadowColor = "rgba(0, 0, 0, 0.6)";
                ctx.shadowBlur = 60 * scaleFactor;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 20 * scaleFactor;
                // Draw main image with new dimensions
                ctx.drawImage(img, realPadding, realPadding, width, height);

                // Matte Inner Border
                if (settings.borderType === 'matte') {
                    const innerWidth = Math.max(1, realPadding * 0.08);
                    const offset = innerWidth / 2;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
                    ctx.lineWidth = innerWidth;
                    // Draw slightly outside the image
                    ctx.strokeRect(realPadding - offset, realPadding - offset, width + innerWidth, height + innerWidth);
                }

                ctx.restore();

                // Text
                if (settings.showExif && exif.hasData) {
                    ctx.save();
                    // Adaptive font size based on border width
                    // Ensure text fits in padding with margins (approx 3 lines height)
                    const maxFontSize = realPadding * 0.28;
                    const defaultFontSize = 36 * scaleFactor;
                    const baseFontSize = Math.min(defaultFontSize, maxFontSize) * settings.fontScale;

                    ctx.fillStyle = "#FFFFFF";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.shadowColor = "rgba(0,0,0,0.9)";
                    ctx.shadowBlur = 6;
                    ctx.shadowOffsetY = 2;

                    const centerX = canvasWidth / 2;

                    // Adaptive positioning: if border is very thick, keep text closer to image
                    const maxCenterOffset = 150 * scaleFactor;
                    const centerOffset = Math.min(realPadding / 2, maxCenterOffset);
                    const bottomBorderCenterY = canvasHeight - realPadding + centerOffset;

                    const lineSpacing = baseFontSize * 1.45;

                    ctx.font = `500 ${baseFontSize}px 'Oswald', sans-serif`;
                    ctx.fillText(exif.camera, centerX, bottomBorderCenterY - (lineSpacing * 0.35));

                    const paramsParts = [exif.focal, exif.fstop, exif.shutter, exif.iso ? `ISO ${exif.iso}` : null];
                    const paramText = paramsParts.filter(Boolean).join("  |  ");

                    if (paramText) {
                        ctx.font = `400 ${baseFontSize * 0.7}px 'Roboto Mono', monospace`;
                        ctx.globalAlpha = 0.9;
                        ctx.fillText(paramText, centerX, bottomBorderCenterY + (lineSpacing * 0.5));
                    }
                    ctx.restore();
                }

                canvas.toBlob((blob) => {
                    const outName = `BorderPro_${filename.replace(/\.[^/.]+$/, "")}.jpg`;
                    this.generatedImagesData.push({ name: outName, blob: blob });
                    this.createResultCard(canvas, outName, blob); // Pass blob
                    resolveCallback();
                }, 'image/jpeg', settings.quality);
            },

            // Simple Box Blur (3 passes)
            stackBlurCanvasRGB(canvas, top_x, top_y, width, height, radius) {
                if (isNaN(radius) || radius < 1) return;
                const ctx = canvas.getContext('2d');
                let imageData;
                try { imageData = ctx.getImageData(top_x, top_y, width, height); } catch (e) { return; }
                const pixels = imageData.data;

                // 3 passes of box blur approximates Gaussian
                // Horizontal
                this.boxBlurH(pixels, width, height, radius);
                this.boxBlurT(pixels, width, height, radius); // Vertical
                this.boxBlurH(pixels, width, height, radius);
                this.boxBlurT(pixels, width, height, radius);

                ctx.putImageData(imageData, top_x, top_y);
            },

            boxBlurH(scl, w, h, r) {
                for (let i = 0; i < h; i++) {
                    for (let j = 0; j < w; j++) {
                        let valR = 0, valG = 0, valB = 0, cnt = 0;
                        for (let k = j - r; k <= j + r; k++) {
                            if (k >= 0 && k < w) {
                                let p = (i * w + k) * 4;
                                valR += scl[p]; valG += scl[p + 1]; valB += scl[p + 2]; cnt++;
                            }
                        }
                        let p = (i * w + j) * 4;
                        scl[p] = valR / cnt; scl[p + 1] = valG / cnt; scl[p + 2] = valB / cnt;
                    }
                }
            },
            boxBlurT(scl, w, h, r) {
                for (let i = 0; i < w; i++) {
                    for (let j = 0; j < h; j++) {
                        let valR = 0, valG = 0, valB = 0, cnt = 0;
                        for (let k = j - r; k <= j + r; k++) {
                            if (k >= 0 && k < h) {
                                let p = (k * w + i) * 4;
                                valR += scl[p]; valG += scl[p + 1]; valB += scl[p + 2]; cnt++;
                            }
                        }
                        let p = (j * w + i) * 4;
                        scl[p] = valR / cnt; scl[p + 1] = valG / cnt; scl[p + 2] = valB / cnt;
                    }
                }
            },

            createResultCard(canvas, filename, blob) { // Accept blob
                const container = document.createElement('div');
                container.className = "bg-gray-100 dark:bg-slate-950 p-3 rounded-xl shadow-md hover:shadow-xl transition-all duration-300 animate-[fadeIn_0.5s_ease-out] h-fit";

                const imgWrapper = document.createElement('div');
                imgWrapper.className = "relative overflow-hidden rounded-lg group";

                const imgPreview = document.createElement('img');
                imgPreview.src = canvas.toDataURL('image/jpeg', 0.7);
                imgPreview.className = "w-full h-auto block";

                const overlay = document.createElement('a');
                overlay.href = URL.createObjectURL(blob);
                overlay.download = filename;
                overlay.className = "absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center cursor-pointer";
                overlay.innerHTML = '<div class="bg-white/20 backdrop-blur-sm rounded-full p-4"><svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg></div>';

                imgWrapper.appendChild(imgPreview);
                imgWrapper.appendChild(overlay);
                container.appendChild(imgWrapper);

                this.elements.gallery.appendChild(container);
            },

            async downloadAll() {
                if (this.generatedImagesData.length === 0) return;
                this.showToast("æ­£åœ¨æ‰“åŒ…å‹ç¼©...", true);
                const zip = new JSZip();
                const folder = zip.folder("BorderMaster_Images");
                this.generatedImagesData.forEach(item => {
                    folder.file(item.name, item.blob);
                });
                try {
                    const content = await zip.generateAsync({ type: "blob" });
                    saveAs(content, "BorderMaster_Output.zip");
                    this.showToast("å¼€å§‹ä¸‹è½½", false);
                    setTimeout(() => this.hideToast(), 2000);
                } catch (e) {
                    console.error(e);
                    this.showToast("æ‰“åŒ…å¤±è´¥", false);
                }
            }
        };

        // --- Watermark Master Logic ---
        const WatermarkApp = {
            state: {
                baseImage: null,
                watermark: {
                    type: 'image', // 'image' or 'text'
                    image: null,
                    text: '',
                    font: 'Dancing Script',
                    color: '#000000',
                    x: 0, y: 0,
                    width: 0, height: 0,
                    scale: 1,
                    opacity: 1,
                    isDragging: false,
                    dragOffsetX: 0,
                    dragOffsetY: 0
                },
                canvas: { width: 0, height: 0 }
            },
            elements: {},

            init() {
                this.elements = {
                    dropZone: document.getElementById('wmDropZone'),
                    imageInput: document.getElementById('wmImageInput'),
                    controls: document.getElementById('wmControls'),
                    emptyState: document.getElementById('wmEmptyState'),
                    mainCanvas: document.getElementById('wmMainCanvas'),

                    // Type Toggle
                    btnTypeImage: document.getElementById('wmTypeImage'),
                    btnTypeText: document.getElementById('wmTypeText'),
                    sectionImage: document.getElementById('wmSectionImage'),
                    sectionText: document.getElementById('wmSectionText'),

                    // Image Watermark
                    uploadBtn: document.getElementById('wmUploadBtn'),
                    watermarkInput: document.getElementById('wmWatermarkInput'),

                    // Text Signature
                    sigText: document.getElementById('wmSigText'),
                    fontSelect: document.getElementById('wmFontSelect'),
                    sigColor: document.getElementById('wmSigColor'),
                    addSigBtn: document.getElementById('wmAddSigBtn'),
                    saveSigBtn: document.getElementById('wmSaveSigBtn'),
                    downloadSigBtn: document.getElementById('wmDownloadSigBtn'),

                    // Adjustments
                    scaleRange: document.getElementById('wmScaleRange'),
                    scaleVal: document.getElementById('wmScaleVal'),
                    opacityRange: document.getElementById('wmOpacityRange'),
                    opacityVal: document.getElementById('wmOpacityVal'),
                    qualityRange: document.getElementById('wmQualityRange'),
                    qualityVal: document.getElementById('wmQualityVal'),
                    exportBtn: document.getElementById('wmExportBtn'),

                    posBtns: document.querySelectorAll('.wm-pos-btn'),

                    // Palette
                    btnTypePalette: document.getElementById('wmTypePalette'),
                    sectionPalette: document.getElementById('wmSectionPalette'),
                    paletteCountRange: document.getElementById('wmPaletteCountRange'),
                    paletteCountVal: document.getElementById('wmPaletteCountVal'),
                    paletteStyle: document.getElementById('wmPaletteStyle'),
                    generatePaletteBtn: document.getElementById('wmGeneratePaletteBtn'),

                    // Histogram
                    btnTypeHistogram: document.getElementById('wmTypeHistogram'),
                    sectionHistogram: document.getElementById('wmSectionHistogram'),
                    histogramStyle: document.getElementById('wmHistogramStyle'),
                    generateHistogramBtn: document.getElementById('wmGenerateHistogramBtn')
                };
                this.setupEventListeners();
                this.loadSignaturePreset();
            },

            setupEventListeners() {
                const els = this.elements;

                // Base Image
                Utils.UI.setupUpload(els.dropZone, els.imageInput, 'border-violet-500', (files) => {
                    if (files.length) this.handleFile(files[0]);
                });
                els.imageInput.addEventListener('change', (e) => this.handleImageUpload(e));

                // Type Toggle
                els.btnTypeImage.addEventListener('click', () => this.switchType('image'));
                els.btnTypeText.addEventListener('click', () => this.switchType('text'));
                els.btnTypePalette.addEventListener('click', () => this.switchType('palette'));
                els.btnTypeHistogram.addEventListener('click', () => this.switchType('histogram'));

                // Watermark Upload
                els.uploadBtn.addEventListener('click', () => els.watermarkInput.click());
                els.watermarkInput.addEventListener('change', (e) => this.handleWatermarkUpload(e));

                // Signature
                els.addSigBtn.addEventListener('click', () => this.addSignatureToCanvas());
                els.saveSigBtn.addEventListener('click', () => this.saveSignaturePreset());
                els.downloadSigBtn.addEventListener('click', () => this.downloadSignature());
                els.sigColor.addEventListener('input', () => this.updateSignature()); // Live update if possible, or just value

                // Palette
                Utils.UI.bindRange(els.paletteCountRange, els.paletteCountVal);
                els.generatePaletteBtn.addEventListener('click', () => this.generatePalette());

                // Histogram
                els.generateHistogramBtn.addEventListener('click', () => this.generateHistogram());

                // Controls
                Utils.UI.bindRange(els.scaleRange, els.scaleVal, (v) => `${v}%`, (v) => {
                    this.state.watermark.scale = v / 100;
                    this.drawCanvas();
                });
                Utils.UI.bindRange(els.opacityRange, els.opacityVal, (v) => `${v}%`, (v) => {
                    this.state.watermark.opacity = v / 100;
                    this.drawCanvas();
                });
                Utils.UI.bindRange(els.qualityRange, els.qualityVal, (v) => `${v}%`);

                // Position
                els.posBtns.forEach(btn => {
                    btn.addEventListener('click', () => this.setWatermarkPosition(btn.dataset.pos));
                });

                // Canvas Interaction
                els.mainCanvas.addEventListener('mousedown', (e) => this.handleCanvasMouseDown(e));
                window.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                window.addEventListener('mouseup', () => this.handleCanvasMouseUp());

                els.mainCanvas.addEventListener('touchstart', (e) => { if (e.touches.length === 1) { /*e.preventDefault();*/ this.handleCanvasMouseDown(e); } }, { passive: false });
                window.addEventListener('touchmove', (e) => { if (this.state.watermark.isDragging) { e.preventDefault(); this.handleCanvasMouseMove(e); } }, { passive: false });
                window.addEventListener('touchend', () => this.handleCanvasMouseUp());

                // Export
                els.exportBtn.addEventListener('click', () => this.exportImage());

                window.addEventListener('resize', () => this.resizeCanvas());
            },

            switchType(type) {
                const els = this.elements;
                const types = ['image', 'text', 'palette', 'histogram'];
                const buttons = {
                    'image': els.btnTypeImage,
                    'text': els.btnTypeText,
                    'palette': els.btnTypePalette,
                    'histogram': els.btnTypeHistogram
                };
                const sections = {
                    'image': els.sectionImage,
                    'text': els.sectionText,
                    'palette': els.sectionPalette,
                    'histogram': els.sectionHistogram
                };

                types.forEach(t => {
                    if (t === type) {
                        buttons[t].classList.add('bg-white', 'dark:bg-gray-600', 'shadow-sm', 'text-violet-600', 'dark:text-blue-400');
                        buttons[t].classList.remove('text-gray-500', 'dark:text-slate-400');
                        sections[t].classList.remove('hidden');
                    } else {
                        buttons[t].classList.remove('bg-white', 'dark:bg-gray-600', 'shadow-sm', 'text-violet-600', 'dark:text-blue-400');
                        buttons[t].classList.add('text-gray-500', 'dark:text-slate-400');
                        sections[t].classList.add('hidden');
                    }
                });
            },

            handleImageUpload(e) {
                if (e.target.files && e.target.files[0]) this.handleFile(e.target.files[0]);
            },

            handleFile(file) {
                Utils.File.readImage(file).then(img => {
                    this.state.baseImage = img;
                    this.state.canvas.width = img.width;
                    this.state.canvas.height = img.height;

                    this.elements.mainCanvas.width = img.width;
                    this.elements.mainCanvas.height = img.height;

                    this.elements.emptyState.classList.add('hidden');
                    this.elements.mainCanvas.classList.remove('hidden');
                    this.elements.controls.classList.remove('hidden');

                    // Enable export button
                    if (this.elements.exportBtn) {
                        this.elements.exportBtn.disabled = false;
                    }

                    this.drawCanvas();
                    this.resizeCanvas();
                });
            },

            handleWatermarkUpload(e) {
                if (e.target.files && e.target.files[0]) {
                    Utils.File.readImage(e.target.files[0]).then(img => {
                        this.setWatermarkImage(img);
                    });
                }
            },

            setWatermarkImage(img) {
                this.state.watermark.image = img;

                // Auto-scale to ~30% of base image width for visibility
                const targetWidth = this.state.canvas.width * 0.3;
                const ratio = img.width / img.height;

                this.state.watermark.width = targetWidth;
                this.state.watermark.height = targetWidth / ratio;

                // Reset defaults
                this.state.watermark.scale = 1;
                this.state.watermark.opacity = 1;
                this.elements.scaleRange.value = 100;
                this.elements.opacityRange.value = 100;
                this.elements.scaleVal.innerText = '100%';
                this.elements.opacityVal.innerText = '100%';

                // Center
                this.state.watermark.x = (this.state.canvas.width - img.width) / 2;
                this.state.watermark.y = (this.state.canvas.height - img.height) / 2;

                this.drawCanvas();
            },

            generatePalette() {
                if (!this.state.baseImage) return;

                const count = parseInt(this.elements.paletteCountRange.value);
                const style = this.elements.paletteStyle.value;

                // 1. Extract Colors (Improved Quantization & Distance Filtering)
                const smallCanvas = document.createElement('canvas');
                const ctx = smallCanvas.getContext('2d');
                // Use slightly larger sample for better accuracy
                smallCanvas.width = 150;
                smallCanvas.height = 150;
                ctx.drawImage(this.state.baseImage, 0, 0, 150, 150);

                const imageData = ctx.getImageData(0, 0, 150, 150).data;
                const colorMap = {};

                // Quantize to reduce color space (round to nearest 16)
                // This groups similar colors together
                for (let i = 0; i < imageData.length; i += 4) {
                    // Ignore fully transparent pixels
                    if (imageData[i + 3] < 128) continue;

                    const r = (imageData[i] >> 4) << 4;
                    const g = (imageData[i + 1] >> 4) << 4;
                    const b = (imageData[i + 2] >> 4) << 4;
                    const key = `${r},${g},${b}`;
                    colorMap[key] = (colorMap[key] || 0) + 1;
                }

                // Sort by frequency
                const sortedCandidates = Object.entries(colorMap)
                    .sort((a, b) => b[1] - a[1])
                    .map(entry => {
                        const [r, g, b] = entry[0].split(',').map(Number);
                        return { r, g, b, count: entry[1] };
                    });

                // Select distinct colors
                const selectedColors = [];
                const minDistance = 45; // Minimum Euclidean distance between colors

                for (const candidate of sortedCandidates) {
                    if (selectedColors.length >= count) break;

                    let isDistinct = true;
                    for (const selected of selectedColors) {
                        const d = Math.sqrt(
                            Math.pow(candidate.r - selected.r, 2) +
                            Math.pow(candidate.g - selected.g, 2) +
                            Math.pow(candidate.b - selected.b, 2)
                        );
                        if (d < minDistance) {
                            isDistinct = false;
                            break;
                        }
                    }

                    if (isDistinct) {
                        selectedColors.push([candidate.r, candidate.g, candidate.b]);
                    }
                }

                // Fallback if we didn't find enough distinct colors (fill with next most frequent)
                if (selectedColors.length < count) {
                    for (const candidate of sortedCandidates) {
                        if (selectedColors.length >= count) break;
                        // Check if already included (exact match)
                        const exists = selectedColors.some(c => c[0] === candidate.r && c[1] === candidate.g && c[2] === candidate.b);
                        if (!exists) {
                            selectedColors.push([candidate.r, candidate.g, candidate.b]);
                        }
                    }
                }

                // 2. Draw Palette
                const pCanvas = document.createElement('canvas');
                const pCtx = pCanvas.getContext('2d');
                const size = 100; // Larger size for better quality
                const gap = 20;

                if (style === 'strip') {
                    pCanvas.width = count * size;
                    pCanvas.height = size;
                    selectedColors.forEach((rgb, i) => {
                        pCtx.fillStyle = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
                        pCtx.fillRect(i * size, 0, size, size);
                    });
                } else {
                    pCanvas.width = (count * size) + ((count - 1) * gap);
                    pCanvas.height = size;

                    selectedColors.forEach((rgb, i) => {
                        const x = i * (size + gap);
                        pCtx.fillStyle = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;

                        if (style === 'circle') {
                            pCtx.beginPath();
                            pCtx.arc(x + size / 2, size / 2, size / 2, 0, Math.PI * 2);
                            pCtx.fill();
                        } else {
                            pCtx.fillRect(x, 0, size, size);
                        }

                        // Border
                        pCtx.strokeStyle = 'rgba(255,255,255,0.5)';
                        pCtx.lineWidth = 4;
                        pCtx.stroke();
                    });
                }

                const img = new Image();
                img.onload = () => this.setWatermarkImage(img);
                img.src = pCanvas.toDataURL();
            },

            generateHistogram() {
                if (!this.state.baseImage) return;

                const style = this.elements.histogramStyle.value;

                // 1. Calculate Histogram
                const smallCanvas = document.createElement('canvas');
                const ctx = smallCanvas.getContext('2d');
                // Use a reasonable size for histogram accuracy
                smallCanvas.width = 256;
                smallCanvas.height = 256;
                ctx.drawImage(this.state.baseImage, 0, 0, 256, 256);

                const imageData = ctx.getImageData(0, 0, 256, 256).data;
                const rHist = new Array(256).fill(0);
                const gHist = new Array(256).fill(0);
                const bHist = new Array(256).fill(0);
                const lHist = new Array(256).fill(0);

                for (let i = 0; i < imageData.length; i += 4) {
                    const r = imageData[i];
                    const g = imageData[i + 1];
                    const b = imageData[i + 2];
                    const l = Math.round(0.299 * r + 0.587 * g + 0.114 * b);

                    rHist[r]++;
                    gHist[g]++;
                    bHist[b]++;
                    lHist[l]++;
                }

                const maxCount = Math.max(...rHist, ...gHist, ...bHist, ...lHist);

                // 2. Draw Histogram
                const hCanvas = document.createElement('canvas');
                const hCtx = hCanvas.getContext('2d');
                const hW = 1024; // High res
                const hH = 400;
                hCanvas.width = hW;
                hCanvas.height = hH;

                // Background (semi-transparent black)
                hCtx.fillStyle = 'rgba(0,0,0,0.5)';
                hCtx.fillRect(0, 0, hW, hH);

                const drawChannel = (hist, color) => {
                    hCtx.fillStyle = color;
                    hCtx.beginPath();
                    hCtx.moveTo(0, hH);
                    for (let i = 0; i < 256; i++) {
                        const h = (hist[i] / maxCount) * hH;
                        const x = (i / 255) * hW;
                        hCtx.lineTo(x, hH - h);
                    }
                    hCtx.lineTo(hW, hH);
                    hCtx.fill();
                };

                hCtx.globalCompositeOperation = 'screen';

                if (style === 'rgb') {
                    drawChannel(rHist, 'rgba(255,0,0,0.6)');
                    drawChannel(gHist, 'rgba(0,255,0,0.6)');
                    drawChannel(bHist, 'rgba(0,0,255,0.6)');
                } else if (style === 'luminance') {
                    drawChannel(lHist, 'rgba(255,255,255,0.8)');
                } else if (style === 'color') {
                    // Simple approximation: just draw RGB
                    drawChannel(rHist, 'rgba(255,0,0,0.6)');
                    drawChannel(gHist, 'rgba(0,255,0,0.6)');
                    drawChannel(bHist, 'rgba(0,0,255,0.6)');
                }

                const img = new Image();
                img.onload = () => this.setWatermarkImage(img);
                img.src = hCanvas.toDataURL();
            },

            addSignatureToCanvas() {
                const text = this.elements.sigText.value || 'Signature';
                const font = this.elements.fontSelect.value;
                const color = this.elements.sigColor.value;

                // Dynamic font size based on canvas width to ensure quality
                const baseWidth = this.state.canvas.width || 1000;
                const fontSize = Math.max(100, Math.floor(baseWidth * 0.15)); // ~15% of width

                const offCanvas = document.createElement('canvas');
                const ctx = offCanvas.getContext('2d');
                ctx.font = `${fontSize}px "${font}"`;
                const metrics = ctx.measureText(text);
                const width = Math.ceil(metrics.width);
                const height = Math.ceil(fontSize * 1.5);

                offCanvas.width = width;
                offCanvas.height = height;

                ctx.font = `${fontSize}px "${font}"`;
                ctx.fillStyle = color;
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, height / 2);

                const img = new Image();
                img.onload = () => this.setWatermarkImage(img);
                img.src = offCanvas.toDataURL();
            },

            updateSignature() {
                // Optional: live preview logic if needed, currently just relies on clicking "Generate"
            },

            saveSignaturePreset() {
                const preset = {
                    text: this.elements.sigText.value,
                    font: this.elements.fontSelect.value,
                    color: this.elements.sigColor.value
                };
                localStorage.setItem('wmSigPreset', JSON.stringify(preset));
                alert('ç­¾åé¢„è®¾å·²ä¿å­˜');
            },

            loadSignaturePreset() {
                const saved = localStorage.getItem('wmSigPreset');
                if (saved) {
                    const preset = JSON.parse(saved);
                    this.elements.sigText.value = preset.text || '';
                    this.elements.fontSelect.value = preset.font || 'Dancing Script';
                    this.elements.sigColor.value = preset.color || '#000000';
                }
            },

            downloadSignature() {
                const text = this.elements.sigText.value || 'Signature';
                const font = this.elements.fontSelect.value;
                const color = this.elements.sigColor.value;
                const fontSize = 100;

                const offCanvas = document.createElement('canvas');
                const ctx = offCanvas.getContext('2d');
                ctx.font = `${fontSize}px "${font}"`;
                const metrics = ctx.measureText(text);
                const width = Math.ceil(metrics.width) + 20;
                const height = Math.ceil(fontSize * 1.5);

                offCanvas.width = width;
                offCanvas.height = height;

                ctx.font = `${fontSize}px "${font}"`;
                ctx.fillStyle = color;
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 10, height / 2);

                const link = document.createElement('a');
                link.download = 'signature.png';
                link.href = offCanvas.toDataURL();
                link.click();
            },

            drawCanvas() {
                if (!this.state.baseImage) return;
                const ctx = this.elements.mainCanvas.getContext('2d');
                ctx.clearRect(0, 0, this.state.canvas.width, this.state.canvas.height);
                ctx.drawImage(this.state.baseImage, 0, 0);

                if (this.state.watermark.image) {
                    ctx.save();
                    ctx.globalAlpha = this.state.watermark.opacity;
                    const w = this.state.watermark.width * this.state.watermark.scale;
                    const h = this.state.watermark.height * this.state.watermark.scale;
                    ctx.drawImage(this.state.watermark.image, this.state.watermark.x, this.state.watermark.y, w, h);
                    ctx.restore();
                }
            },

            setWatermarkPosition(pos) {
                if (!this.state.watermark.image || !this.state.baseImage) return;
                const w = this.state.watermark.width * this.state.watermark.scale;
                const h = this.state.watermark.height * this.state.watermark.scale;
                const padding = 40;

                let x = 0, y = 0;
                switch (pos) {
                    case 'top-left': x = padding; y = padding; break;
                    case 'top-center': x = (this.state.canvas.width - w) / 2; y = padding; break;
                    case 'top-right': x = this.state.canvas.width - w - padding; y = padding; break;
                    case 'center-left': x = padding; y = (this.state.canvas.height - h) / 2; break;
                    case 'center': x = (this.state.canvas.width - w) / 2; y = (this.state.canvas.height - h) / 2; break;
                    case 'center-right': x = this.state.canvas.width - w - padding; y = (this.state.canvas.height - h) / 2; break;
                    case 'bottom-left': x = padding; y = this.state.canvas.height - h - padding; break;
                    case 'bottom-center': x = (this.state.canvas.width - w) / 2; y = this.state.canvas.height - h - padding; break;
                    case 'bottom-right': x = this.state.canvas.width - w - padding; y = this.state.canvas.height - h - padding; break;
                }
                this.state.watermark.x = x;
                this.state.watermark.y = y;
                this.drawCanvas();
            },

            getCanvasCoordinates(e) {
                const rect = this.elements.mainCanvas.getBoundingClientRect();
                const scaleX = this.elements.mainCanvas.width / rect.width;
                const scaleY = this.elements.mainCanvas.height / rect.height;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
            },

            handleCanvasMouseDown(e) {
                if (!this.state.watermark.image) return;
                const pos = this.getCanvasCoordinates(e);
                const w = this.state.watermark.width * this.state.watermark.scale;
                const h = this.state.watermark.height * this.state.watermark.scale;

                if (pos.x >= this.state.watermark.x && pos.x <= this.state.watermark.x + w &&
                    pos.y >= this.state.watermark.y && pos.y <= this.state.watermark.y + h) {
                    this.state.watermark.isDragging = true;
                    this.state.watermark.dragOffsetX = pos.x - this.state.watermark.x;
                    this.state.watermark.dragOffsetY = pos.y - this.state.watermark.y;
                    this.elements.mainCanvas.classList.add('cursor-grabbing');
                }
            },

            handleCanvasMouseMove(e) {
                if (!this.state.watermark.isDragging) return;
                const pos = this.getCanvasCoordinates(e);
                this.state.watermark.x = pos.x - this.state.watermark.dragOffsetX;
                this.state.watermark.y = pos.y - this.state.watermark.dragOffsetY;
                this.drawCanvas();
            },

            handleCanvasMouseUp() {
                this.state.watermark.isDragging = false;
                this.elements.mainCanvas.classList.remove('cursor-grabbing');
            },

            exportImage() {
                if (!this.state.baseImage) return;
                const quality = this.elements.qualityRange.value / 100;
                const dataURL = this.elements.mainCanvas.toDataURL('image/jpeg', quality);
                const link = document.createElement('a');
                link.download = 'watermarked-image.jpg';
                link.href = dataURL;
                link.click();
            },

            resizeCanvas() {
                // Optional: CSS max-w-full handles display size, but we could adjust if needed.
            }
        };

        // --- Tag Master Logic ---
        const TagMasterApp = {
            state: {
                imageList: [], // Array of { id, file, processedData, tags, status, error }
                settings: {
                    tagCount: 15,
                    language: 'auto'
                }
            },

            elements: {},

            init() {
                this.elements = {
                    dropZone: document.getElementById('tagDropZone'),
                    fileInput: document.getElementById('tagFileInput'),
                    tagCountRange: document.getElementById('tagCountRange'),
                    tagCountVal: document.getElementById('tagCountVal'),
                    tagLanguage: document.getElementById('tagLanguage'),
                    generateBtn: document.getElementById('tagGenerateBtn'),
                    emptyState: document.getElementById('tagEmptyState'),
                    gridContainer: document.getElementById('tagGridContainer'),
                    grid: document.getElementById('tagGrid'),
                    tagResultSection: document.getElementById('tagResultSection'),
                    copyAllBtn: document.getElementById('tagCopyAllBtn'),
                    clearAllBtn: document.getElementById('tagClearAllBtn')
                };

                this.loadSettings();
                this.setupEventListeners();
            },

            loadSettings() {
                const saved = localStorage.getItem('tagMasterSettings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        if (settings.tagCount) this.state.settings.tagCount = settings.tagCount;
                        if (settings.language) this.state.settings.language = settings.language;

                        this.elements.tagCountRange.value = this.state.settings.tagCount;
                        this.elements.tagCountVal.textContent = this.state.settings.tagCount;
                        this.elements.tagLanguage.value = this.state.settings.language;
                    } catch (e) {
                        console.error('Failed to load settings:', e);
                    }
                }
            },

            setupEventListeners() {
                // Upload
                Utils.UI.setupUpload(this.elements.dropZone, this.elements.fileInput, 'border-violet-500', (files) => {
                    this.handleImageUpload(files);
                });
                this.elements.fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleImageUpload(e.target.files);
                    }
                });

                // Settings
                Utils.UI.bindRange(this.elements.tagCountRange, this.elements.tagCountVal, (v) => v, (v) => {
                    this.state.settings.tagCount = parseInt(v);
                });
                this.elements.tagLanguage.addEventListener('change', (e) => {
                    this.state.settings.language = e.target.value;
                });

                // Generate
                this.elements.generateBtn.addEventListener('click', () => this.generateTagsBatch());

                // Copy All
                this.elements.copyAllBtn.addEventListener('click', () => this.copyAllTags());

                // Clear All
                this.elements.clearAllBtn.addEventListener('click', () => {
                    this.clearHistory();
                });
            },

            async handleImageUpload(files) {
                const newImages = Array.from(files).filter(file => file.type.startsWith('image/'));

                if (newImages.length === 0) {
                    alert('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
                    return;
                }

                // Process each image
                for (const file of newImages) {
                    const id = Date.now().toString(36) + Math.random().toString(36).substr(2);

                    // Add to state immediately with pending status
                    const imageItem = {
                        id,
                        file,
                        processedData: null,
                        tags: [],
                        status: 'loading', // loading image data
                        error: null
                    };
                    this.state.imageList.push(imageItem);

                    // Render immediately
                    this.renderGrid();

                    try {
                        // Load and process image
                        const img = await this.loadImage(file);
                        const processedData = await this.compressAndStripEXIF(img);

                        // Update state
                        imageItem.processedData = processedData;
                        imageItem.status = 'pending'; // ready for AI

                        // Re-render
                        this.renderGrid();
                    } catch (error) {
                        console.error('Image processing error:', error);
                        imageItem.status = 'error';
                        imageItem.error = 'å›¾ç‰‡åŠ è½½å¤±è´¥';
                        this.renderGrid();
                    }
                }

                // Update UI visibility
                if (this.state.imageList.length > 0) {
                    this.elements.emptyState.classList.add('hidden');
                    this.elements.gridContainer.classList.remove('hidden');
                    this.elements.generateBtn.disabled = false;
                    this.elements.tagResultSection.classList.remove('hidden');
                }
            },

            loadImage(file) {
                return Utils.File.readImage(file);
            },

            async compressAndStripEXIF(img) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // Compress to max 1024px
                const MAX_SIZE = 1024;
                let width = img.width;
                let height = img.height;

                if (width > MAX_SIZE || height > MAX_SIZE) {
                    if (width > height) {
                        height = (height / width) * MAX_SIZE;
                        width = MAX_SIZE;
                    } else {
                        width = (width / height) * MAX_SIZE;
                        height = MAX_SIZE;
                    }
                }

                canvas.width = width;
                canvas.height = height;

                // Draw image (this strips EXIF data)
                ctx.drawImage(img, 0, 0, width, height);

                // Convert to base64 with quality 0.7
                return canvas.toDataURL('image/jpeg', 0.7);
            },

            renderGrid() {
                this.elements.grid.innerHTML = '';

                this.state.imageList.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'bg-white dark:bg-slate-900 rounded-xl shadow-lg overflow-hidden flex flex-col transition-all hover:shadow-xl';

                    // Image Area
                    const imgContainer = document.createElement('div');
                    imgContainer.className = 'relative h-48 bg-gray-100 dark:bg-slate-950 group';

                    if (item.processedData) {
                        const img = document.createElement('img');
                        img.src = item.processedData;
                        img.className = 'w-full h-full object-cover';
                        imgContainer.appendChild(img);
                    } else {
                        // Loading placeholder
                        imgContainer.innerHTML = '<div class="w-full h-full flex items-center justify-center"><div class="animate-spin rounded-full h-8 w-8 border-2 border-violet-500 border-t-transparent"></div></div>';
                    }

                    // Remove Button (overlay)
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'absolute top-2 right-2 p-1.5 bg-black/50 hover:bg-red-500 text-white rounded-full opacity-0 group-hover:opacity-100 transition-all';
                    removeBtn.innerHTML = '<i class="fa-solid fa-xmark"></i>';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.removeImage(item.id);
                    };
                    imgContainer.appendChild(removeBtn);

                    // Status Overlay
                    if (item.status === 'processing') {
                        const statusOverlay = document.createElement('div');
                        statusOverlay.className = 'absolute inset-0 bg-black/50 flex items-center justify-center text-white backdrop-blur-sm';
                        statusOverlay.innerHTML = '<div class="flex flex-col items-center gap-2"><div class="animate-spin rounded-full h-8 w-8 border-2 border-white border-t-transparent"></div><span class="text-xs">ç”Ÿæˆä¸­...</span></div>';
                        imgContainer.appendChild(statusOverlay);
                    } else if (item.status === 'error') {
                        const errorOverlay = document.createElement('div');
                        errorOverlay.className = 'absolute inset-0 bg-red-500/80 flex items-center justify-center text-white backdrop-blur-sm p-4 text-center';
                        errorOverlay.innerHTML = `<div class="flex flex-col items-center gap-2"><i class="fa-solid fa-triangle-exclamation text-2xl"></i><span class="text-xs">${item.error || 'å¤±è´¥'}</span></div>`;
                        imgContainer.appendChild(errorOverlay);
                    }

                    // ... (image container above) ...

                    // Content Area
                    const content = document.createElement('div');
                    content.className = 'p-4 flex-1 flex flex-col gap-3';

                    // Actions (Now at top)
                    const actions = document.createElement('div');
                    actions.className = 'flex justify-between items-center pb-2 border-b border-gray-100 dark:border-slate-800 mb-1';

                    // Copy Button
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'text-xs text-gray-500 hover:text-blue-500 flex items-center gap-1 disabled:opacity-50 disabled:cursor-not-allowed';
                    copyBtn.innerHTML = `<i class="fa-solid fa-copy"></i> <span data-i18n="content.btn.copy">${appTranslations[currentLang]['content.btn.copy']}</span>`;
                    copyBtn.disabled = !item.tags || item.tags.length === 0;
                    copyBtn.onclick = () => this.copyItemTags(item);

                    // Retry Button
                    const retryBtn = document.createElement('button');
                    retryBtn.className = 'text-xs text-gray-500 hover:text-blue-500 flex items-center gap-1';
                    retryBtn.innerHTML = `<i class="fa-solid fa-rotate"></i> <span data-i18n="btn.retry">${appTranslations[currentLang]['btn.retry']}</span>`;
                    retryBtn.onclick = () => this.generateSingleTag(item);

                    actions.appendChild(copyBtn);
                    actions.appendChild(retryBtn);

                    // Tags Area (Now below actions)
                    const tagsArea = document.createElement('div');
                    tagsArea.className = 'flex-1 min-h-[60px] flex flex-wrap gap-1.5 content-start';

                    if (item.tags && item.tags.length > 0) {
                        const colors = [
                            'bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300',
                            'bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300',
                            'bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300',
                            'bg-pink-100 text-pink-700 dark:bg-pink-900/30 dark:text-pink-300',
                            'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-300',
                            'bg-indigo-100 text-indigo-700 dark:bg-indigo-900/30 dark:text-indigo-300'
                        ];

                        item.tags.forEach((tag, idx) => {
                            const colorClass = colors[idx % colors.length];
                            const chip = document.createElement('span');
                            chip.className = `inline-flex items-center gap-1 px-2 py-1 rounded-md text-xs font-medium ${colorClass}`;
                            chip.innerHTML = `${tag} <button class="hover:text-red-500 ml-0.5" onclick="TagMasterApp.removeTag('${item.id}', ${idx})">Ã—</button>`;
                            tagsArea.appendChild(chip);
                        });
                    } else if (item.status === 'pending') {
                        tagsArea.innerHTML = `<span class="text-xs text-gray-400 italic" data-i18n="content.waiting">${appTranslations[currentLang]['content.waiting']}</span>`;
                    }

                    // Append in new order
                    content.appendChild(actions); // Actions first
                    content.appendChild(tagsArea); // Tags second

                    card.appendChild(imgContainer);
                    card.appendChild(content);
                    this.elements.grid.appendChild(card);
                });
            },

            clearHistory() {
                this.state.imageList = [];
                this.renderGrid();
                this.elements.emptyState.classList.remove('hidden');
                this.elements.gridContainer.classList.add('hidden');
                this.elements.generateBtn.disabled = true;
                this.elements.tagResultSection.classList.add('hidden');
            },

            removeImage(id) {
                this.state.imageList = this.state.imageList.filter(item => item.id !== id);
                this.renderGrid();

                if (this.state.imageList.length === 0) {
                    this.elements.emptyState.classList.remove('hidden');
                    this.elements.gridContainer.classList.add('hidden');
                    this.elements.generateBtn.disabled = true;
                    this.elements.tagResultSection.classList.add('hidden');
                }
            },

            removeTag(itemId, tagIndex) {
                const item = this.state.imageList.find(i => i.id === itemId);
                if (item) {
                    item.tags.splice(tagIndex, 1);
                    this.renderGrid();
                }
            },

            copyItemTags(item) {
                if (!item.tags || item.tags.length === 0) return;
                const text = item.tags.join(', ');
                navigator.clipboard.writeText(text).then(() => {
                    // Optional: toast feedback
                });
            },

            async generateTagsBatch() {
                if (!AISettings.settings.apiKey) {
                    alert('è¯·å…ˆé…ç½®AI APIè®¾ç½®');
                    AISettings.openModal();
                    return;
                }

                // Filter only pending or error items, skip already done items
                const pendingItems = this.state.imageList.filter(item => item.status === 'pending' || item.status === 'error');
                if (pendingItems.length === 0) {
                    alert('æ²¡æœ‰éœ€è¦å¤„ç†çš„å›¾ç‰‡');
                    return;
                }

                this.elements.generateBtn.disabled = true;
                this.elements.generateBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> <span>ç”Ÿæˆä¸­...</span>';

                // Process sequentially to avoid rate limits
                for (const item of pendingItems) {
                    await this.generateSingleTag(item);
                }

                this.elements.generateBtn.disabled = false;
                this.elements.generateBtn.innerHTML = '<i class="fa-solid fa-wand-magic-sparkles"></i> <span>ç”Ÿæˆæ ‡ç­¾</span>';
            },

            async generateSingleTag(item) {
                item.status = 'processing';
                item.error = null;
                this.renderGrid();

                try {
                    const tags = await this.callAIAPI(item.processedData);
                    item.tags = tags;
                    item.status = 'done';
                } catch (error) {
                    console.error('Tag generation error:', error);
                    item.status = 'error';
                    item.error = error.message;
                }
                this.renderGrid();
            },

            async callAIAPI(imageData) {
                const { apiProvider, apiEndpoint, apiKey, modelName } = AISettings.settings;
                const { tagCount, language } = this.state.settings;

                // Build prompt
                let langInstruction = '';
                if (language === 'zh') langInstruction = 'Please respond in Chinese. ';
                else if (language === 'en') langInstruction = 'Please respond in English. ';

                const prompt = `${langInstruction}Analyze this image and generate exactly ${tagCount} relevant tags or keywords that describe the content, style, mood, colors, objects, and themes. Return ONLY a comma-separated list of tags, nothing else.`;

                let requestBody;
                if (apiProvider === 'openai') {
                    requestBody = {
                        model: modelName,
                        messages: [
                            {
                                role: 'user',
                                content: [
                                    { type: 'text', text: prompt },
                                    { type: 'image_url', image_url: { url: imageData } }
                                ]
                            }
                        ],
                        max_tokens: 300
                    };
                } else if (apiProvider === 'gemini') {
                    // Gemini format (simplified)
                    requestBody = {
                        contents: [{
                            parts: [
                                { text: prompt },
                                { inline_data: { mime_type: 'image/jpeg', data: imageData.split(',')[1] } }
                            ]
                        }]
                    };
                } else {
                    // Custom format - assume OpenAI-like
                    requestBody = {
                        model: modelName,
                        messages: [
                            {
                                role: 'user',
                                content: [
                                    { type: 'text', text: prompt },
                                    { type: 'image_url', image_url: { url: imageData } }
                                ]
                            }
                        ]
                    };
                }

                const response = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();

                // Parse response based on provider
                let tagsText;
                if (apiProvider === 'openai' || apiProvider === 'custom') {
                    tagsText = data.choices[0].message.content;
                } else if (apiProvider === 'gemini') {
                    tagsText = data.candidates[0].content.parts[0].text;
                }

                // Parse tags from comma-separated text
                const tags = tagsText.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
                return tags.slice(0, tagCount); // Ensure we don't exceed requested count
            },

            copyAllTags() {
                const itemsWithTags = this.state.imageList.filter(item => item.tags && item.tags.length > 0);
                if (itemsWithTags.length === 0) {
                    alert((appTranslations[currentLang]['tag.no_tags'] || 'æ²¡æœ‰å¯å¤åˆ¶çš„æ ‡ç­¾'));
                    return;
                }

                let text = '';
                itemsWithTags.forEach((item, index) => {
                    text += `[å›¾ç‰‡ ${index + 1}]: ${item.tags.join(', ')}\n`;
                });

                navigator.clipboard.writeText(text).then(() => {
                    const btn = this.elements.copyAllBtn;
                    const originalHtml = btn.innerHTML;
                    btn.innerHTML = `<i class="fa-solid fa-check"></i> ${appTranslations[currentLang]['btn.copied']}`;
                    setTimeout(() => {
                        btn.innerHTML = originalHtml;
                    }, 2000);
                });
            }
        };

        // --- Global AI Settings ---
        const AISettings = {
            settings: {
                apiProvider: 'openai',
                apiEndpoint: 'https://api.openai.com/v1/chat/completions',
                apiKey: '',
                modelName: 'gpt-4-vision-preview',
                // Text generation model (for wallpaper prompt generation)
                textModelEndpoint: 'https://api.openai.com/v1/chat/completions',
                textModelKey: '',
                textModelName: 'gpt-4',
                // Image generation model (for wallpaper creation)
                imageGenEndpoint: 'https://api.openai.com/v1/images/generations',
                imageGenKey: '',
                imageGenModelName: 'dall-e-3'
            },
            elements: {},

            init() {
                this.elements = {
                    modal: document.getElementById('tagApiModal'),
                    modalClose: document.getElementById('tagApiModalClose'),
                    provider: document.getElementById('tagApiProvider'),
                    endpoint: document.getElementById('tagApiEndpoint'),
                    key: document.getElementById('tagApiKey'),
                    modelName: document.getElementById('tagModelName'),
                    // Text generation model elements
                    textModelEndpoint: document.getElementById('textModelEndpoint'),
                    textModelKey: document.getElementById('textModelKey'),
                    textModelName: document.getElementById('textModelName'),
                    // Image generation model elements
                    imageGenEndpoint: document.getElementById('imageGenEndpoint'),
                    imageGenKey: document.getElementById('imageGenKey'),
                    imageGenModelName: document.getElementById('imageGenModelName'),
                    testBtn: document.getElementById('tagApiTest'),
                    saveBtn: document.getElementById('tagApiSave'),
                    globalBtn: document.getElementById('globalApiSettingsBtn')
                };

                this.loadSettings();
                this.setupEventListeners();
            },

            setupEventListeners() {
                this.elements.modalClose.addEventListener('click', () => this.closeModal());
                this.elements.modal.addEventListener('click', (e) => {
                    if (e.target === this.elements.modal) this.closeModal();
                });
                this.elements.provider.addEventListener('change', (e) => this.updateDefaults(e.target.value));
                this.elements.saveBtn.addEventListener('click', () => this.saveSettings());
                this.elements.testBtn.addEventListener('click', () => this.testConnection());
                if (this.elements.globalBtn) {
                    this.elements.globalBtn.addEventListener('click', () => this.openModal());
                }
            },

            openModal() {
                this.elements.provider.value = this.settings.apiProvider;
                this.elements.endpoint.value = this.settings.apiEndpoint;
                this.elements.key.value = this.settings.apiKey;
                this.elements.modelName.value = this.settings.modelName;
                // Text generation model
                this.elements.textModelEndpoint.value = this.settings.textModelEndpoint;
                this.elements.textModelKey.value = this.settings.textModelKey;
                this.elements.textModelName.value = this.settings.textModelName;
                // Image generation model
                this.elements.imageGenEndpoint.value = this.settings.imageGenEndpoint;
                this.elements.imageGenKey.value = this.settings.imageGenKey;
                this.elements.imageGenModelName.value = this.settings.imageGenModelName;
                this.elements.modal.classList.remove('hidden');
            },

            closeModal() {
                this.elements.modal.classList.add('hidden');
            },

            updateDefaults(provider) {
                if (provider === 'openai') {
                    this.elements.endpoint.value = 'https://api.openai.com/v1/chat/completions';
                    this.elements.modelName.value = 'gpt-4-vision-preview';
                } else if (provider === 'gemini') {
                    this.elements.endpoint.value = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro-vision:generateContent';
                    this.elements.modelName.value = 'gemini-pro-vision';
                }
            },

            saveSettings() {
                this.settings.apiProvider = this.elements.provider.value;
                this.settings.apiEndpoint = this.elements.endpoint.value;
                this.settings.apiKey = this.elements.key.value;
                this.settings.modelName = this.elements.modelName.value;
                // Text generation model
                this.settings.textModelEndpoint = this.elements.textModelEndpoint.value;
                this.settings.textModelKey = this.elements.textModelKey.value;
                this.settings.textModelName = this.elements.textModelName.value;
                // Image generation model
                this.settings.imageGenEndpoint = this.elements.imageGenEndpoint.value;
                this.settings.imageGenKey = this.elements.imageGenKey.value;
                this.settings.imageGenModelName = this.elements.imageGenModelName.value;

                localStorage.setItem('aiSettings', JSON.stringify(this.settings));

                const saveBtn = this.elements.saveBtn;
                const originalText = saveBtn.innerHTML;
                saveBtn.innerHTML = '<i class="fa-solid fa-check"></i> å·²ä¿å­˜';
                saveBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                saveBtn.classList.add('bg-green-600', 'hover:bg-green-700');

                setTimeout(() => {
                    this.closeModal();
                    setTimeout(() => {
                        saveBtn.innerHTML = originalText;
                        saveBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                        saveBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    }, 300);
                }, 800);
            },

            async testConnection() {
                const testBtn = this.elements.testBtn;
                const originalText = testBtn.textContent;
                testBtn.textContent = 'æµ‹è¯•ä¸­...';
                testBtn.disabled = true;

                try {
                    const response = await fetch(this.elements.endpoint.value, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.elements.key.value}`
                        },
                        body: JSON.stringify({ test: true })
                    });

                    if (response.status === 401) {
                        alert('APIå¯†é’¥æ— æ•ˆ');
                    } else if (response.status === 404) {
                        alert('APIç«¯ç‚¹ä¸å­˜åœ¨');
                    } else {
                        alert('è¿æ¥æˆåŠŸï¼');
                    }
                } catch (error) {
                    alert('è¿æ¥å¤±è´¥: ' + error.message);
                } finally {
                    testBtn.textContent = originalText;
                    testBtn.disabled = false;
                }
            },

            loadSettings() {
                const saved = localStorage.getItem('aiSettings');
                if (saved) {
                    try {
                        this.settings = { ...this.settings, ...JSON.parse(saved) };
                    } catch (e) {
                        console.error('Failed to load AI settings:', e);
                    }
                }
            }
        };

        // --- Content Master Logic ---
        const ContentMasterApp = {
            state: {
                image: null,
                imageData: null,
                userInput: '',
                style: 'general',
                generatedTitle: '',
                generatedContent: '',
                isGenerating: false
            },
            elements: {},

            init() {
                this.elements = {
                    dropZone: document.getElementById('contentDropZone'),
                    fileInput: document.getElementById('contentFileInput'),
                    userInput: document.getElementById('contentUserInput'),
                    styleSelect: document.getElementById('contentStyle'),
                    generateBtn: document.getElementById('contentGenerateBtn'),
                    emptyState: document.getElementById('contentEmptyState'),
                    container: document.getElementById('contentContainer'),
                    previewImage: document.getElementById('contentPreviewImage'),
                    titleDisplay: document.getElementById('contentTitleDisplay'),
                    contentDisplay: document.getElementById('contentTextDisplay'),
                    copyTitleBtn: document.getElementById('contentCopyTitleBtn'),
                    copyContentBtn: document.getElementById('contentCopyContentBtn'),
                    copyAllBtn: document.getElementById('contentCopyAllBtn')
                };

                this.setupEventListeners();
            },

            setupEventListeners() {
                Utils.UI.setupUpload(this.elements.dropZone, this.elements.fileInput, 'border-violet-500', (files) => {
                    if (files.length) this.handleImageUpload(files[0]);
                });
                this.elements.fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length) this.handleImageUpload(e.target.files[0]);
                });

                this.elements.generateBtn.addEventListener('click', () => this.generateContent());
                this.elements.copyTitleBtn.addEventListener('click', () => this.copyTitle());
                this.elements.copyContentBtn.addEventListener('click', () => this.copyContent());
                this.elements.copyAllBtn.addEventListener('click', () => this.copyAll());
            },

            async handleImageUpload(file) {
                try {
                    const img = await Utils.File.readImage(file);
                    this.state.image = img;

                    // Compress image for API
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const MAX_SIZE = 1024;
                    let width = img.width;
                    let height = img.height;

                    if (width > MAX_SIZE || height > MAX_SIZE) {
                        if (width > height) {
                            height = (height / width) * MAX_SIZE;
                            width = MAX_SIZE;
                        } else {
                            width = (width / height) * MAX_SIZE;
                            height = MAX_SIZE;
                        }
                    }

                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    this.state.imageData = canvas.toDataURL('image/jpeg', 0.7);

                    // Update UI
                    this.elements.previewImage.src = this.state.imageData;
                    this.elements.emptyState.classList.add('hidden');
                    this.elements.container.classList.remove('hidden');
                    this.elements.generateBtn.disabled = false;

                    // Reset generated content
                    this.state.generatedTitle = '';
                    this.state.generatedContent = '';
                    this.elements.titleDisplay.innerHTML = '<span class="text-gray-400 italic">ç­‰å¾…ç”Ÿæˆ...</span>';
                    this.elements.contentDisplay.innerHTML = '<span class="text-gray-400 italic">ç­‰å¾…ç”Ÿæˆ...</span>';
                } catch (e) {
                    console.error('Failed to load image:', e);
                    alert('å›¾ç‰‡åŠ è½½å¤±è´¥');
                }
            },

            async generateContent() {
                if (!this.state.imageData || !AISettings.settings.apiKey) {
                    alert('è¯·å…ˆä¸Šä¼ å›¾ç‰‡å¹¶é…ç½®APIè®¾ç½®');
                    return;
                }

                this.state.isGenerating = true;
                const btn = this.elements.generateBtn;
                const originalHtml = btn.innerHTML;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> <span>ç”Ÿæˆä¸­...</span>';
                btn.disabled = true;

                try {
                    const userInput = this.elements.userInput.value.trim();
                    const style = this.elements.styleSelect.value;

                    // Build prompt
                    let stylePrompt = '';
                    switch (style) {
                        case 'zhongcao':
                            stylePrompt = 'ç§è‰é£æ ¼ï¼Œçªå‡ºäº§å“ä¼˜ç‚¹ï¼Œå¸å¼•è´­ä¹°ï¼Œä½¿ç”¨å¤¸å¼ å’Œæ„Ÿå¹çš„è¯­æ°”';
                            break;
                        case 'photography':
                            stylePrompt = 'æ‘„å½±é£æ ¼ï¼Œæ³¨é‡ç”»é¢æ„å›¾ã€å…‰å½±æè¿°ï¼Œåˆ†äº«æ‹æ‘„å‚æ•°å’Œä¿®å›¾æ€è·¯ï¼Œæƒ…æ„Ÿç»†è…»';
                            break;
                        case 'tutorial':
                            stylePrompt = 'æ•™ç¨‹é£æ ¼ï¼Œæ­¥éª¤æ¸…æ™°ï¼Œå¹²è´§æ»¡æ»¡ï¼Œæ˜“äºç†è§£';
                            break;
                        case 'daily':
                            stylePrompt = 'æ—¥å¸¸åˆ†äº«é£æ ¼ï¼Œè½»æ¾è‡ªç„¶ï¼Œç”Ÿæ´»åŒ–';
                            break;
                        default:
                            stylePrompt = 'é€šç”¨é£æ ¼ï¼Œå¸å¼•äºº';
                    }

                    const prompt = `è¯·æ ¹æ®è¿™å¼ å›¾ç‰‡ç”Ÿæˆå°çº¢ä¹¦é£æ ¼çš„å†…å®¹ã€‚${userInput ? 'è¡¥å……ä¿¡æ¯ï¼š' + userInput + 'ã€‚' : ''}é£æ ¼è¦æ±‚ï¼š${stylePrompt}ã€‚

è¯·æŒ‰ä»¥ä¸‹æ ¼å¼è¾“å‡ºï¼š
ã€æ ‡é¢˜ã€‘ä¸€è¡Œç®€çŸ­å¸å¼•äººçš„æ ‡é¢˜ï¼ˆ20-30å­—ï¼Œå¯åŒ…å«emojiï¼‰
ã€æ­£æ–‡ã€‘å¤šæ®µè½æ­£æ–‡å†…å®¹ï¼ˆä½¿ç”¨emojiã€è¯é¢˜æ ‡ç­¾#ï¼Œåˆ†æ®µæ¸…æ™°ï¼‰

è¦æ±‚ï¼š
1. æ ‡é¢˜è¦å¸å¼•çœ¼çƒï¼ŒåŒ…å«1-3ä¸ªç›¸å…³emoji
2. æ­£æ–‡è¦æœ‰æ„ŸæŸ“åŠ›ï¼Œè‡ªç„¶åˆ†æ®µï¼Œé€‚å½“ä½¿ç”¨emoji
3. ç»“å°¾åŠ 2-3ä¸ªç›¸å…³è¯é¢˜æ ‡ç­¾
4. æ•´ä½“é£æ ¼ç¬¦åˆå°çº¢ä¹¦è°ƒæ€§`;

                    const { apiProvider, apiEndpoint, apiKey, modelName } = AISettings.settings;

                    let requestBody;
                    if (apiProvider === 'openai' || apiProvider === 'custom') {
                        requestBody = {
                            model: modelName,
                            messages: [
                                {
                                    role: 'user',
                                    content: [
                                        { type: 'text', text: prompt },
                                        { type: 'image_url', image_url: { url: this.state.imageData } }
                                    ]
                                }
                            ],
                            max_tokens: 500
                        };
                    } else if (apiProvider === 'gemini') {
                        requestBody = {
                            contents: [{
                                parts: [
                                    { text: prompt },
                                    { inline_data: { mime_type: 'image/jpeg', data: this.state.imageData.split(',')[1] } }
                                ]
                            }]
                        };
                    }

                    const response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();

                    let resultText;
                    if (apiProvider === 'openai' || apiProvider === 'custom') {
                        resultText = data.choices[0].message.content;
                    } else if (apiProvider === 'gemini') {
                        resultText = data.candidates[0].content.parts[0].text;
                    }

                    // Parse result
                    const titleMatch = resultText.match(/ã€æ ‡é¢˜ã€‘(.+?)(?=\n|ã€|$)/);
                    const contentMatch = resultText.match(/ã€æ­£æ–‡ã€‘([\s\S]+)/);

                    if (titleMatch) {
                        this.state.generatedTitle = titleMatch[1].trim();
                        this.elements.titleDisplay.textContent = this.state.generatedTitle;
                    } else {
                        this.elements.titleDisplay.innerHTML = '<span class="text-red-400">æ ‡é¢˜è§£æå¤±è´¥</span>';
                    }

                    if (contentMatch) {
                        this.state.generatedContent = contentMatch[1].trim();
                        this.elements.contentDisplay.textContent = this.state.generatedContent;
                    } else {
                        this.elements.contentDisplay.innerHTML = '<span class="text-red-400">æ­£æ–‡è§£æå¤±è´¥</span>';
                    }

                } catch (error) {
                    console.error('Content generation error:', error);
                    alert('ç”Ÿæˆå¤±è´¥: ' + error.message);
                    this.elements.titleDisplay.innerHTML = '<span class="text-red-400">ç”Ÿæˆå¤±è´¥</span>';
                    this.elements.contentDisplay.innerHTML = '<span class="text-red-400">ç”Ÿæˆå¤±è´¥</span>';
                } finally {
                    this.state.isGenerating = false;
                    btn.innerHTML = originalHtml;
                    btn.disabled = false;
                }
            },

            copyTitle() {
                if (!this.state.generatedTitle) return;
                navigator.clipboard.writeText(this.state.generatedTitle).then(() => {
                    const btn = this.elements.copyTitleBtn;
                    const originalHtml = btn.innerHTML;
                    btn.innerHTML = `<i class="fa-solid fa-check"></i> ${appTranslations[currentLang]['btn.copied']}`;
                    setTimeout(() => btn.innerHTML = originalHtml, 2000);
                });
            },

            copyContent() {
                if (!this.state.generatedContent) return;
                navigator.clipboard.writeText(this.state.generatedContent).then(() => {
                    const btn = this.elements.copyContentBtn;
                    const originalHtml = btn.innerHTML;
                    btn.innerHTML = `<i class="fa-solid fa-check"></i> ${appTranslations[currentLang]['btn.copied']}`;
                    setTimeout(() => btn.innerHTML = originalHtml, 2000);
                });
            },

            copyAll() {
                if (!this.state.generatedTitle || !this.state.generatedContent) return;
                const text = `${this.state.generatedTitle}\n\n${this.state.generatedContent}`;
                navigator.clipboard.writeText(text).then(() => {
                    const btn = this.elements.copyAllBtn;
                    const originalHtml = btn.innerHTML;
                    btn.innerHTML = `<i class="fa-solid fa-check"></i> ${appTranslations[currentLang]['btn.copied']}`;
                    setTimeout(() => btn.innerHTML = originalHtml, 2000);
                });
            }
        };

        // --- Sidebar Resize Logic ---
        function setupSidebarResize() {
            const sidebar = document.getElementById('mainSidebar');
            const resizer = document.getElementById('sidebarResizer');
            let isResizing = false;

            // Load saved width
            const savedWidth = localStorage.getItem('sidebarWidth');
            if (savedWidth) {
                sidebar.style.width = `${savedWidth}px`;
            }

            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.classList.add('select-none'); // Prevent text selection

                // Add overlay to prevent iframe/canvas interference
                const overlay = document.createElement('div');
                overlay.id = 'resizeOverlay';
                overlay.className = 'fixed inset-0 z-[100] cursor-col-resize';
                document.body.appendChild(overlay);
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const newWidth = e.clientX;
                // Constraints are handled by CSS min-width/max-width, but good to clamp here too
                if (newWidth >= 280 && newWidth <= 600) {
                    sidebar.style.width = `${newWidth}px`;
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.classList.remove('select-none');

                    const overlay = document.getElementById('resizeOverlay');
                    if (overlay) overlay.remove();

                    // Save width
                    localStorage.setItem('sidebarWidth', sidebar.offsetWidth);
                }
            });
        }

        // --- Wallpaper Master Logic ---
        const WallpaperApp = {
            state: {
                mode: 'ai', // 'ai' or 'custom'
                style: 'nature',
                aspectRatio: '9:16', // For AI generation
                deviceSize: 'iphone15promax', // For custom image mode
                customImage: null,
                canvasScale: 1,
                canvasX: 0,
                canvasY: 0,
                generatedWallpaper: null,
                generatedPrompt: '',
                isGenerating: false,
                isDragging: false,
                lastX: 0,
                lastY: 0
            },
            elements: {},
            // API-allowed sizes mapped to aspect ratios
            sizePresets: {
                '16:9': { width: 1664, height: 928, label: '16:9 æ¨ªå±' },
                '4:3': { width: 1472, height: 1140, label: '4:3 æ¨ªå±' },
                '1:1': { width: 1328, height: 1328, label: '1:1 æ­£æ–¹å½¢' },
                '3:4': { width: 1140, height: 1472, label: '3:4 ç«–å±' },
                '9:16': { width: 928, height: 1664, label: '9:16 ç«–å±' }
            },
            // Legacy presets for custom image mode
            phonePresets: {
                'iphone15promax': { width: 1290, height: 2796 },
                'iphone15pro': { width: 1179, height: 2556 },
                'iphone15': { width: 1179, height: 2556 },
                'iphone14pro': { width: 1179, height: 2556 },
                'iphone14': { width: 1170, height: 2532 },
                'iphone13': { width: 1170, height: 2532 },
                'iphonese': { width: 750, height: 1334 },
                'fhd': { width: 1080, height: 1920 },
                'qhd': { width: 1440, height: 2560 },
                '4k': { width: 2160, height: 3840 }
            },

            init() {
                this.elements = {
                    // Mode toggle
                    modeAI: document.getElementById('wallpaperModeAI'),
                    modeCustom: document.getElementById('wallpaperModeCustom'),
                    // AI section
                    aiSection: document.getElementById('wallpaperAISection'),
                    styleSelect: document.getElementById('wallpaperStyle'),
                    aspectRatioSelect: document.getElementById('wallpaperAspectRatio'),
                    generateBtn: document.getElementById('wallpaperGenerateBtn'),
                    generateBtnText: document.getElementById('wallpaperGenerateBtnText'),
                    generateBtnIcon: document.getElementById('wallpaperGenerateBtnIcon'),
                    // Custom section
                    customSection: document.getElementById('wallpaperCustomSection'),
                    dropZone: document.getElementById('wallpaperDropZone'),
                    fileInput: document.getElementById('wallpaperFileInput'),
                    deviceSection: document.getElementById('wallpaperDeviceSection'),
                    deviceSizeSelect: document.getElementById('wallpaperDeviceSize'),
                    scaleSection: document.getElementById('wallpaperScaleSection'),
                    scaleRange: document.getElementById('wallpaperScaleRange'),
                    scaleVal: document.getElementById('wallpaperScaleVal'),
                    resetSection: document.getElementById('wallpaperResetSection'),
                    resetBtn: document.getElementById('wallpaperResetBtn'),
                    // Common
                    qualityRange: document.getElementById('wallpaperQuality'),
                    qualityVal: document.getElementById('wallpaperQualityVal'),
                    downloadBtn: document.getElementById('wallpaperDownloadBtn'),
                    // Main area
                    emptyState: document.getElementById('wallpaperEmptyState'),
                    canvasContainer: document.getElementById('wallpaperCanvasContainer'),
                    canvas: document.getElementById('wallpaperCanvas'),
                    canvasHint: document.getElementById('wallpaperCanvasHint'),
                    previewContainer: document.getElementById('wallpaperPreviewContainer'),
                    previewImage: document.getElementById('wallpaperPreviewImage'),
                    loadingOverlay: document.getElementById('wallpaperLoadingOverlay'),
                    loadingText: document.getElementById('wallpaperLoadingText')
                };

                this.setupEventListeners();
            },

            setupEventListeners() {
                // Mode toggle
                this.elements.modeAI.addEventListener('click', () => this.switchMode('ai'));
                this.elements.modeCustom.addEventListener('click', () => this.switchMode('custom'));

                // AI mode
                this.elements.styleSelect.addEventListener('change', (e) => {
                    this.state.style = e.target.value;
                });
                this.elements.aspectRatioSelect.addEventListener('change', (e) => {
                    this.state.aspectRatio = e.target.value;
                });
                this.elements.generateBtn.addEventListener('click', () => this.generateAIWallpaper());

                // Custom mode
                Utils.UI.setupUpload(this.elements.dropZone, this.elements.fileInput, 'border-violet-500', (files) => {
                    if (files.length > 0) this.handleCustomImage(files[0]);
                });
                this.elements.fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) this.handleCustomImage(e.target.files[0]);
                });
                this.elements.deviceSizeSelect.addEventListener('change', (e) => {
                    this.state.deviceSize = e.target.value;

                    // Recalculate scale to cover the new canvas size
                    if (this.state.customImage) {
                        const preset = this.phonePresets[this.state.deviceSize];
                        const scaleX = preset.width / this.state.customImage.width;
                        const scaleY = preset.height / this.state.customImage.height;
                        const initialScale = Math.max(scaleX, scaleY);

                        this.state.canvasScale = initialScale;
                        this.elements.scaleRange.value = Math.round(initialScale * 100);
                        this.elements.scaleVal.textContent = `${Math.round(initialScale * 100)}%`;
                    }

                    this.renderCustomCanvas();
                });
                Utils.UI.bindRange(this.elements.scaleRange, this.elements.scaleVal, (v) => `${v}%`, (v) => {
                    this.state.canvasScale = parseInt(v) / 100;
                    this.renderCustomCanvas();
                });
                this.elements.resetBtn.addEventListener('click', () => this.resetCustomPosition());

                // Common
                Utils.UI.bindRange(this.elements.qualityRange, this.elements.qualityVal, (v) => `${v}%`);
                this.elements.downloadBtn.addEventListener('click', () => this.downloadWallpaper());

                // Canvas interaction
                this.setupCanvasInteraction();
            },

            switchMode(mode) {
                this.state.mode = mode;

                if (mode === 'ai') {
                    this.elements.modeAI.classList.add('bg-white', 'dark:bg-gray-600', 'shadow-sm', 'text-violet-600', 'dark:text-blue-400');
                    this.elements.modeAI.classList.remove('text-gray-500', 'dark:text-slate-400');
                    this.elements.modeCustom.classList.remove('bg-white', 'dark:bg-gray-600', 'shadow-sm', 'text-violet-600', 'dark:text-blue-400');
                    this.elements.modeCustom.classList.add('text-gray-500', 'dark:text-slate-400');
                    this.elements.aiSection.classList.remove('hidden');
                    this.elements.customSection.classList.add('hidden');
                } else {
                    this.elements.modeCustom.classList.add('bg-white', 'dark:bg-gray-600', 'shadow-sm', 'text-violet-600', 'dark:text-blue-400');
                    this.elements.modeCustom.classList.remove('text-gray-500', 'dark:text-slate-400');
                    this.elements.modeAI.classList.remove('bg-white', 'dark:bg-gray-600', 'shadow-sm', 'text-violet-600', 'dark:text-blue-400');
                    this.elements.modeAI.classList.add('text-gray-500', 'dark:text-slate-400');
                    this.elements.aiSection.classList.add('hidden');
                    this.elements.customSection.classList.remove('hidden');
                }
            },

            async generateAIWallpaper() {
                if (this.state.isGenerating) return;

                // Check API settings
                const { textModelEndpoint, textModelKey, imageGenEndpoint, imageGenKey } = AISettings.settings;
                if (!textModelKey || !imageGenKey) {
                    alert('è¯·å…ˆåœ¨AI APIè®¾ç½®ä¸­é…ç½®æ–‡æœ¬ç”Ÿæˆæ¨¡å‹å’Œå›¾åƒç”Ÿæˆæ¨¡å‹');
                    AISettings.openModal();
                    return;
                }

                this.state.isGenerating = true;
                this.showLoading('æ­£åœ¨ç”Ÿæˆå£çº¸æè¿°...');

                try {
                    // Step 1: Generate prompt using text model
                    const prompt = await this.generatePrompt();
                    this.state.generatedPrompt = prompt;

                    // Step 2: Generate image using image generation model
                    this.updateLoadingText('æ­£åœ¨ç”Ÿæˆå£çº¸å›¾ç‰‡...');
                    const imageUrl = await this.generateImage(prompt);

                    // Step 3: Load and display the image
                    await this.loadGeneratedImage(imageUrl);

                    // Update button state to "Regenerate"
                    this.elements.generateBtnText.textContent = 'é‡æ–°ç”Ÿæˆ';
                    this.elements.generateBtnIcon.className = 'fa-solid fa-rotate-right';
                    this.elements.generateBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                    this.elements.generateBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                    this.elements.downloadBtn.disabled = false;
                    Utils.Toast.show('å£çº¸ç”ŸæˆæˆåŠŸï¼', false);
                    setTimeout(() => Utils.Toast.hide(), 2000);

                } catch (error) {
                    console.error('Failed to generate wallpaper:', error);
                    alert('ç”Ÿæˆå£çº¸å¤±è´¥: ' + error.message);
                } finally {
                    this.state.isGenerating = false;
                    this.hideLoading();
                }
            },

            async generatePrompt() {
                const { textModelEndpoint, textModelKey, textModelName } = AISettings.settings;

                // 1. Random Modifiers (Atmosphere & Lighting)
                const timeOfDay = ['dawn', 'morning', 'noon', 'golden hour', 'sunset', 'blue hour', 'starry night', 'moonlight'];
                const weather = ['clear and sunny', 'partly cloudy', 'dramatic storm clouds', 'misty and ethereal', 'foggy', 'light rain', 'snowy', 'windy'];
                const lighting = ['soft diffused light', 'dramatic shadows', 'cinematic lighting', 'volumetric lighting', 'bioluminescent glow', 'neon lights', 'natural sunlight'];
                const colorPalettes = ['vibrant and saturated', 'pastel and soft', 'moody and dark', 'monochromatic', 'warm earth tones', 'cool aquatic tones', 'cyberpunk neon'];

                // 2. Rich Sub-themes for each Style
                const styleThemes = {
                    'nature': [
                        'Majestic mountains with snow peaks reflecting in a crystal clear lake',
                        'Deep ancient forest with sunlight filtering through leaves (god rays)',
                        'Tropical beach with turquoise water and palm trees at sunset',
                        'Vast desert dunes under a starry sky',
                        'Cascading waterfall in a lush jungle',
                        'Autumn forest with colorful red and orange leaves',
                        'Blooming flower field in spring with butterflies',
                        'Northern lights (Aurora Borealis) over a snowy landscape',
                        'Underwater coral reef teeming with marine life'
                    ],
                    'cityscape': [
                        'Futuristic cyberpunk city with neon lights and flying cars',
                        'Modern metropolis skyline at night with city lights',
                        'Quiet european cobblestone street in the morning rain',
                        'Busy intersection in Tokyo with colorful signboards',
                        'Ancient lost city ruins overgrown with nature',
                        'Steampunk industrial city with gears and steam',
                        'Floating city in the clouds',
                        'Rainy noir city street with reflections'
                    ],
                    'abstract': [
                        'Fluid acrylic paint pouring art with swirling colors',
                        'Geometric 3D shapes floating in zero gravity',
                        'Fractal patterns with infinite complexity',
                        'Smoke dispersion in colorful lighting',
                        'Liquid metal flowing textures',
                        'Digital glitch art aesthetic',
                        'Kaleidoscope of crystals and light'
                    ],
                    'minimalist': [
                        'Single tree on a rolling hill, minimal composition',
                        'Zen garden with sand raked patterns and one stone',
                        'Gradient sky fading from blue to pink',
                        'Abstract architectural curves and shadows',
                        'White marble texture with subtle gold veins',
                        'Foggy landscape with silhouette of a mountain',
                        'Paper cut art style landscape'
                    ],
                    'anime': [
                        'Studio Ghibli style lush meadow with fluffy clouds',
                        'Cyberpunk anime girl looking at city skyline (back view)',
                        'Magical fantasy forest with glowing spirits',
                        'Slice of life school rooftop at sunset',
                        'Epic fantasy battleground with magic effects',
                        'Cozy anime bedroom with lo-fi vibe',
                        'Mecha robot in a futuristic hangar'
                    ],
                    'space': [
                        'Nebula with vibrant pink and blue gas clouds',
                        'View of Earth from the moon surface',
                        'Black hole with accretion disk bending light',
                        'Alien planet landscape with double suns',
                        'Astronaut floating in deep space',
                        'Galaxy spiral with millions of stars',
                        'Space station orbiting a gas giant'
                    ],
                    'gradient': [
                        'Holographic iridescent foil texture',
                        'Soft mesh gradient with pastel colors',
                        'Dark moody gradient with grain texture',
                        'Sunset sky gradient from orange to purple',
                        'Aurora borealis color gradient',
                        'Liquid glass dispersion gradient'
                    ],
                    'pattern': [
                        'Japanese wave pattern (Seigaiha) modern interpretation',
                        'Art Deco geometric gold and black pattern',
                        'Seamless floral pattern vintage style',
                        'Memphis design style 80s pattern',
                        'Islamic geometric tile pattern',
                        'Bauhaus style abstract shapes pattern'
                    ]
                };

                // Helper to get random item
                const getRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];

                // Select random elements
                const selectedStyle = this.state.style;
                const randomTheme = getRandom(styleThemes[selectedStyle] || styleThemes['nature']);
                const randomTime = getRandom(timeOfDay);
                const randomWeather = getRandom(weather);
                const randomLighting = getRandom(lighting);
                const randomPalette = getRandom(colorPalettes);

                const systemPrompt = 'You are a professional AI Art Prompt Engineer. Create a highly detailed, vivid, and creative prompt for DALL-E 3 based on the user\'s request. Focus on visual descriptions, composition, textures, and lighting. Return ONLY the prompt text.';

                const userPrompt = `Create a wallpaper prompt based on this theme: "${randomTheme}".
                
Style: ${selectedStyle}
Modifiers to include:
- Time: ${randomTime}
- Weather: ${randomWeather}
- Lighting: ${randomLighting}
- Color Palette: ${randomPalette}

Requirements:
1. NO text, NO phones, NO devices, NO borders. Pure background image.
2. High resolution, 8k, masterpiece, highly detailed.
3. Aspect ratio suitable for wallpaper.
4. Composition should be balanced and suitable for a background.

Make the description vivid and artistic. Combine the theme with the modifiers naturally.`;

                const response = await fetch(textModelEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${textModelKey}`
                    },
                    body: JSON.stringify({
                        model: textModelName,
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userPrompt }
                        ],
                        temperature: 0.95 // High creativity
                    })
                });

                if (!response.ok) {
                    throw new Error(`Text model API error: ${response.status}`);
                }

                const data = await response.json();
                return data.choices[0].message.content.trim();
            },

            async generateImage(prompt) {
                const { imageGenEndpoint, imageGenKey, imageGenModelName } = AISettings.settings;
                const preset = this.sizePresets[this.state.aspectRatio];

                // Build size string in format "WIDTHxHEIGHT"
                const sizeString = `${preset.width}x${preset.height}`;

                // Image generation API call
                const response = await fetch(imageGenEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${imageGenKey}`
                    },
                    body: JSON.stringify({
                        model: imageGenModelName,
                        prompt: prompt,
                        n: 1,
                        size: sizeString,
                        quality: 'hd'
                    })
                });

                if (!response.ok) {
                    throw new Error(`Image generation API error: ${response.status}`);
                }

                const data = await response.json();
                return data.data[0].url;
            },

            async loadGeneratedImage(imageUrl) {
                // Directly load image without fetch to avoid CORS issues
                // Browsers allow <img> tags to display cross-origin images
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        this.state.generatedWallpaper = img;
                        this.elements.previewImage.src = imageUrl;
                        this.showPreview();
                        resolve();
                    };
                    img.onerror = (error) => {
                        console.error('Failed to load image:', error);
                        reject(new Error('Failed to load generated image'));
                    };
                    // Don't set crossOrigin to avoid CORS preflight
                    img.src = imageUrl;
                });
            },

            async handleCustomImage(file) {
                try {
                    const img = await Utils.File.readImage(file);
                    this.state.customImage = img;
                    this.state.canvasX = 0;
                    this.state.canvasY = 0;

                    // Calculate initial scale to cover the canvas (like background-size: cover)
                    const preset = this.phonePresets[this.state.deviceSize];
                    const scaleX = preset.width / img.width;
                    const scaleY = preset.height / img.height;
                    const initialScale = Math.max(scaleX, scaleY); // Use max to cover

                    this.state.canvasScale = initialScale;
                    this.elements.scaleRange.value = Math.round(initialScale * 100);
                    this.elements.scaleVal.textContent = `${Math.round(initialScale * 100)}%`;

                    this.elements.deviceSection.classList.remove('hidden');
                    this.elements.scaleSection.classList.remove('hidden');
                    this.elements.resetSection.classList.remove('hidden');
                    this.elements.downloadBtn.disabled = false;

                    this.renderCustomCanvas();
                    this.showCanvas();
                } catch (error) {
                    console.error('Failed to load image:', error);
                    alert('å›¾ç‰‡åŠ è½½å¤±è´¥');
                }
            },

            renderCustomCanvas() {
                if (!this.state.customImage) return;

                const preset = this.phonePresets[this.state.deviceSize];
                const canvas = this.elements.canvas;
                const ctx = canvas.getContext('2d');

                // Set canvas size to phone preset
                canvas.width = preset.width;
                canvas.height = preset.height;

                // Calculate display size (fit to container)
                const container = this.elements.canvasContainer.parentElement;
                const maxWidth = container.clientWidth - 64;
                const maxHeight = container.clientHeight - 64;
                const scale = Math.min(maxWidth / preset.width, maxHeight / preset.height, 1);
                canvas.style.width = `${preset.width * scale}px`;
                canvas.style.height = `${preset.height * scale}px`;

                // Clear canvas
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw image with current transform
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(this.state.canvasScale, this.state.canvasScale);
                ctx.translate(this.state.canvasX, this.state.canvasY);
                ctx.drawImage(
                    this.state.customImage,
                    -this.state.customImage.width / 2,
                    -this.state.customImage.height / 2
                );
                ctx.restore();

                // Show hint
                this.elements.canvasHint.classList.remove('opacity-0');
                setTimeout(() => this.elements.canvasHint.classList.add('opacity-0'), 3000);
            },

            setupCanvasInteraction() {
                const canvas = this.elements.canvas;

                canvas.addEventListener('mousedown', (e) => {
                    this.state.isDragging = true;
                    this.state.lastX = e.clientX;
                    this.state.lastY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (!this.state.isDragging) return;
                    const dx = e.clientX - this.state.lastX;
                    const dy = e.clientY - this.state.lastY;
                    this.state.canvasX += dx / this.state.canvasScale;
                    this.state.canvasY += dy / this.state.canvasScale;
                    this.state.lastX = e.clientX;
                    this.state.lastY = e.clientY;
                    this.renderCustomCanvas();
                });

                canvas.addEventListener('mouseup', () => {
                    this.state.isDragging = false;
                    canvas.style.cursor = 'move';
                });

                canvas.addEventListener('mouseleave', () => {
                    this.state.isDragging = false;
                    canvas.style.cursor = 'move';
                });

                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    this.state.canvasScale = Math.max(0.5, Math.min(5, this.state.canvasScale + delta));
                    this.elements.scaleRange.value = Math.round(this.state.canvasScale * 100);
                    this.elements.scaleVal.textContent = `${Math.round(this.state.canvasScale * 100)}%`;
                    this.renderCustomCanvas();
                });
            },

            resetCustomPosition() {
                if (!this.state.customImage) return;

                this.state.canvasX = 0;
                this.state.canvasY = 0;

                // Recalculate initial scale to cover the canvas
                const preset = this.phonePresets[this.state.deviceSize];
                const scaleX = preset.width / this.state.customImage.width;
                const scaleY = preset.height / this.state.customImage.height;
                const initialScale = Math.max(scaleX, scaleY);

                this.state.canvasScale = initialScale;
                this.elements.scaleRange.value = Math.round(initialScale * 100);
                this.elements.scaleVal.textContent = `${Math.round(initialScale * 100)}%`;
                this.renderCustomCanvas();
            },

            downloadWallpaper() {
                const quality = parseInt(this.elements.qualityRange.value) / 100;

                if (this.state.mode === 'ai' && this.state.generatedWallpaper) {
                    // For AI generated wallpapers, open in new tab for manual download
                    // (CORS prevents direct download)
                    const imageUrl = this.elements.previewImage.src;
                    window.open(imageUrl, '_blank');
                    Utils.Toast.show('å›¾ç‰‡å·²åœ¨æ–°æ ‡ç­¾é¡µæ‰“å¼€ï¼Œè¯·å³é”®ä¿å­˜', false);
                    setTimeout(() => Utils.Toast.hide(), 3000);
                } else if (this.state.mode === 'custom' && this.state.customImage) {
                    // Download custom wallpaper from canvas
                    const canvas = this.elements.canvas;
                    canvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = `wallpaper_custom_${this.state.deviceSize}_${Date.now()}.jpg`;
                        link.click();
                        URL.revokeObjectURL(url);
                    }, 'image/jpeg', quality);
                }
            },

            showLoading(text) {
                this.elements.emptyState.classList.add('hidden');
                this.elements.canvasContainer.classList.add('hidden');
                this.elements.previewContainer.classList.remove('hidden');
                this.elements.loadingOverlay.classList.remove('hidden');
                this.elements.loadingText.textContent = text;
            },

            updateLoadingText(text) {
                this.elements.loadingText.textContent = text;
            },

            hideLoading() {
                this.elements.loadingOverlay.classList.add('hidden');
            },

            showPreview() {
                this.elements.emptyState.classList.add('hidden');
                this.elements.canvasContainer.classList.add('hidden');
                this.elements.previewContainer.classList.remove('hidden');
            },

            showCanvas() {
                this.elements.emptyState.classList.add('hidden');
                this.elements.previewContainer.classList.add('hidden');
                this.elements.canvasContainer.classList.remove('hidden');
            }
        };

        // Run
        init();
    </script>
</body>

</html>